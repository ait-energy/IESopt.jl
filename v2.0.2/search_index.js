var documenterSearchIndex = {"docs":
[{"location":"pages/tutorials/templates_1/#Templates:-Part-I","page":"Templates: Part I","title":"Templates: Part I","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Templates are a powerful feature of IESopt that allow you to define new types of \"components\" by yourself. This makes use of the existing CoreComponents, and combines them in multiple ways, which allows for a high degree of flexibility without having to write any mathematical model yourself.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"This tutorial will guide you through the process of creating a new template, and we will do that on the example of creating the HeatPump template.","category":"page"},{"location":"pages/tutorials/templates_1/#The-basic-structure","page":"Templates: Part I","title":"The basic structure","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"A template is defined by a YAML file, similar to the config.iesopt.yaml file that you already know. First, we need to think about the parameters that we want to define for our heat pump. Let's create a new file for that. The pre-defined one is called HeatPump, so we need a different name: Templates must always have a unique name.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Possibilities for that could be:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"CustomHeatPump, if you do not have any more details\nGroundSourceHeatPump, if we want to implement a ground-source heat pump with different parameters/features than the standard one\nFooHeatPump, if you need it specifically for a project called \"Foo\"","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"info: Naming conventions\nTemplates follow a naming convention similar to PascalCase:The name must start with an upper-case letter\nIt must consist of at least two letters\nNumbers and special characters are not allowed","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's go with CustomHeatPump for now. Create a new file CustomHeatPump.iesopt.template.yaml (if you are already working on a model, the best place to put this would be a templates/ folder), and add the following lines:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"parameters:\n  p_nom: null\n  electricity_from: null\n  heat_from: null\n  heat_to: null\n  cop: null","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"This defines the basic parameters that we want to use for our heat pump. The null values indicate that they all default to nothing in Julia, which corresponds to None in Python. Let's go through them:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"p_nom: The nominal power of the heat pump, which will be specified on the electricity input side\nelectricity_from: The Node that this heat pump is connected to for electricity input\nheat_from: The Node that this heat pump is connected to for heat input\nheat_to: The Node that this heat pump is connected to for heat output\ncop: The coefficient of performance of the heat pump","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Next, we will set up the actual component. This is done in the component section of the template file. Let's add the following lines:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"component:\n  type: Unit\n  inputs: {electricity: <electricity_from>, heat: <heat_from>}\n  outputs: {heat: <heat_to>}\n  conversion: 1 electricity + (<cop> - 1) heat -> <cop> heat\n  capacity: <p_nom> in:electricity","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"This defines the component that we want to create. The type is Unit, which is a core component type in IESopt that you are already familiar with. Instead of providing fixed values, we make use of the parameters that we defined above. This is done by using the <...> syntax.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"That's it! You have created a new template. You can now use this template in your model configuration, as you would with any other component. For example, you could add the following lines to your config.iesopt.yaml file:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"# other parts of the configuration file\n# ...\n\ncomponents:\n  # some other components\n  # ...\n\n  heat_pump:\n    template: CustomHeatPump\n    parameters:\n      p_nom: 10\n      electricity_from: electricity\n      heat_from: ambient\n      heat_to: heating\n      cop: 3","category":"page"},{"location":"pages/tutorials/templates_1/#Accounting-for-different-configurations","page":"Templates: Part I","title":"Accounting for different configurations","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"But wait. What if you want to have different configurations for your heat pump? For example, you might want to have a heat pump that does not explicitly consume any heat, because they low-temperature heat source is not explicitly modeled. Currently, the template does not allow for that, because the heat_from parameter is mandatory.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Why do we know it is mandatory? Because it is used in the inputs section of the Unit definition. But that is not clear, or transparent. Before we continue, we will fill in the mandatory documentation fields for the template. We do that by adding the following information directly at the beginning of the template file, right before the parameters:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"# # Custom Heat Pump\n\n# A (custom) heat pump that consumes electricity and heat, and produces heat.\n\n# ## Parameters\n# - `p_nom`: The nominal power (electricity) of the heat pump.\n# - `electricity_from`: The `Node` that this heat pump is connected to for electricity input.\n# - `heat_from`: The `Node` that this heat pump is connected to for heat input.\n# - `heat_to`: The `Node` that this heat pump is connected to for heat output.\n# - `cop`: The coefficient of performance of the heat pump.\n\n# ## Components\n# _to be added_\n\n# ## Usage\n# _to be added_\n\n# ## Details\n# _to be added_\n\nparameters:\n  # ...","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"info: Docstring format\nAll of that is actually just Markdown inserted into your template. However, make sure to stick to separating the leading # from the actual text by a space, as this is required for IESopt to better understand your documentation.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Now, every user of the template will see this information, and they will notice, that none of the parameters are marked as optional. As you see, there are a lot of other sections to be added, but we will fill them out at the end, after we have finished the template, see the section on finalizing the docstring.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's continue with accounting for different configurations. We will cover the following steps:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Making the heat_from parameter optional\nExtending the template to allow for sizing the heat pump (an investment decision)\nHandling more complex COP configurations","category":"page"},{"location":"pages/tutorials/templates_1/#Optional-parameter-and-sizing-decision","page":"Templates: Part I","title":"Optional parameter and sizing decision","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"While there are multiple ways to make a parameter optional, we will make use of the most powerful one, so that you are able to apply it for your models as well. For that, we will add \"complex\" functionalities to the template, which is done using three different \"functions\":","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"validate: This function is called when the template is parsed, and it is used to check if the parameters are valid. If they are not, an error is thrown. This helps to inform the user of any misconfiguration.\nprepare: This function is called when the template is instantiated, and it is used to prepare the component for usage. This can be used to set default values, or to calculate derived parameters (which we will use to tackle the three additions mentioned above).\nfinalize: This function is called when the template is finalized, and it enables a wide range of options. We will  use this to allow a smooth result extraction for the heat pump, but you could also use it to add additional (more  complex) constraints to the component, or even modify the model's objective function.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's start by adding the functions entry (which we suggest doing at the end of the file):","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"# ... the whole docstring ...\n\nparameters:\n  # ...\n\ncomponent:\n  # ...\n\nfunctions:\n  validate: |\n    # ... we will put the validation code here ...\n  prepare: |\n    # ... we will put the preparation code here ...\n  finalize: |\n    # ... we will put the finalization code here ...","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"The | at the end of the line indicates that the following lines are a multiline string. This is a YAML feature that allows you to write more complex code in a more readable way.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's start by filling out the validation function. Everything you do and write here, is interpreted as Julia code, and compiled directly into your model. This means that you can use all the power of Julia, but also that you need to be careful with what you do. You have access to certain helper functions and constants, which we will introduce here. If you have never written a line of Julia code, don't worry. We will guide you through this - it's actually (at least for the parts that you will need) extremely similar to Python.","category":"page"},{"location":"pages/tutorials/templates_1/#Validation","page":"Templates: Part I","title":"Validation","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"The validation function is used to check if the parameters are valid. Add the following code to the validate section:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"functions:\n  validate: |\n    # Check if `p_nom` is non-negative.\n    @check get(\"p_nom\") isa Number\n    @check get(\"p_nom\") >= 0\n\n    # Check if the `Node` parameters are `String`s, where `heat_from` may also be `nothing`.\n    @check get(\"electricity_from\") isa String\n    @check get(\"heat_from\") isa String || isnothing(get(\"heat_from\"))\n    @check get(\"heat_to\") isa String\n\n    # Check if `cop` is positive.\n    @check get(\"cop\") isa Number\n    @check get(\"cop\") > 0\n  # ... the rest of the template ...","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's go through this step by step:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"You can start comments (as separate line or inline) with #, as you would in Python.\nYou can use get(\"some_param\") to access the value of a parameter.\nYou can use @check to check if a condition is met. If it is not, an error will be thrown. All statements starting with @ are so called \"macros\", which are just \"special\" functions. You can do @check(condition) or @check condition, since macros do not require parentheses.\nYou can use isa to check if a value is of a certain type. This is similar to isinstance in Python. While it is a special keyword, if you prefer, you can also call it in a more conventional way: isa(get(\"p_nom\"), Number).\nData types are capitalized in Julia, so it is String instead of string, and Number is a superset of all numeric types (if necessary you could instead, e.g., check for get(\"some_param\") isa Int).\nLogical operators are similar to Python, so || is like or, and && is like and.\nIf all checks pass, the template is considered valid, and the model can be built.","category":"page"},{"location":"pages/tutorials/templates_1/#Preparation","page":"Templates: Part I","title":"Preparation","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Next, we will add the preparation function. This function is used to prepare the component for usage. Since we would like to make the heat_from parameter optional, and we would like to account for optional sizing, we will first modify the parameters accordingly:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"parameters:\n  p_nom: null\n  p_nom_max: null\n  electricity_from: null\n  heat_from: null\n  heat_to: null\n  cop: null\n  _inputs: null\n  _conversion: null\n  _capacity: null\n  _invest: null","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"One step at a time. We added the following parameters:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"p_nom_max: The maximum nominal power of the heat pump. This is optional, and if not specified, it will default to p_nom, which will disable the sizing feature.\n_inputs: This is an internal / private parameter (since it starts with an underscore), which we will user later. These parameters are not exposed to the user, and can not be set or modified from the outside.\n_capacity: This is another internal parameter, which we will use to store the capacity of the heat pump (which could now either bne p_nom or whatever the investment decision results in).\n_conversion: This is another internal parameter, which we will use to store the conversion formula.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Before we can actually add the code for the prepare function, we need to modify our component definition, as well. We (1) will change from component to components (since it now contains more than just one), (2) will add a Decision that should handle the sizing / investment, and modify the Unit slightly:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"components:\n  unit:\n    type: Unit\n    inputs: <_inputs>\n    outputs: {heat: <heat_to>}\n    conversion: <_conversion>\n    capacity: <_capacity> in:electricity\n  \n  decision:\n    type: Decision\n    enabled: <_invest>\n    lb: <p_nom>\n    ub: <p_nom_max>","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"So ... a lot of changes. Let's go through them step by step:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"We changed component to components, because we now have multiple components.\nWe added a unit component, which is the actual heat pump. We replaced the fixed values with the internal parameters.\nWe added a new component decision, which is a Decision. This component is used to handle investment decisions. It is enabled if _invest evaluates to true. It has a lower bound lb and an upper bound ub, which are the minimum and maximum values that the decision can take. In our case, the decision is the nominal power of the heat pump, which can be between p_nom and p_nom_max.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"info: Naming the components\nThe names of the components are arbitrary, and you can choose whatever you like. However, it is recommended to use meaningful names, so that you can easily understand what the component does. Component names follow a naming convention similar to snake_case: They must start with a lower-case letter, and can contain numbers and underscores (but are not allowed to end in an _). They can further contain ., but this is \"dangerous\" and an expert feature, that you should not use unless you know what it does, and why you need it.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Onto the actual functionality. Let's add the prepare function, and some additional validation code:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"functions:\n  validate: |\n    # ... the previous validation code ...\n\n    # Check if `p_nom_max` is either `nothing` or at least `p_nom`.\n    @check isnothing(get(\"p_nom_max\")) || (get(\"p_nom_max\") isa Number && get(\"p_nom_max\") >= get(\"p_nom\"))\n  prepare: |\n    # Determine if investment should be enabled, and set the parameter (used to enable `decision`).\n    invest = !isnothing(get(\"p_nom_max\")) && get(\"p_nom_max\") > get(\"p_nom\")\n    self = get(\"self\")\n\n    set(\"_invest\", invest)\n    if invest\n        # Set the capacity to the size of the decision variable.\n        set(\"_capacity\", \"$(self).decision:value\")\n    else\n        # Set the capacity to the value of `p_nom`.\n        set(\"_capacity\", get(\"p_nom\"))\n    end\n\n    # Prepare some helper variables to make the code afterwards more readable.\n    elec_from = get(\"electricity_from\")\n    heat_from = get(\"heat_from\")\n    cop = get(\"cop\")\n\n    # Handle the optional `heat_from` parameter.\n    if isnothing(heat_from)\n        # If `heat_from` is not specified, we just use electricity as input.\n        set(\"_inputs\", \"{electricity: $(elec_from)}\")\n        set(\"_conversion\", \"1 electricity -> $(cop) heat\")\n    else\n        # If `heat_from` is specified, we now have to account for two inputs.\n        set(\"_inputs\", \"{electricity: $(elec_from), heat: $(heat_from)}\")\n        set(\"_conversion\", \"1 electricity + $(cop - 1) heat -> $(cop) heat\")\n    end","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Once again, let's go through this step by step:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#Complex-COP-configurations","page":"Templates: Part I","title":"Complex COP configurations","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#The-finalize-function","page":"Templates: Part I","title":"The finalize function","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#Finalizing-the-docstring","page":"Templates: Part I","title":"Finalizing the docstring","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#Conclusion","page":"Templates: Part I","title":"Conclusion","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"details: Complete template YAML\n# # Custom Heat Pump\n\n# A (custom) heat pump that consumes electricity and heat, and produces heat.\n\n# ## Parameters\n# - `p_nom`: The nominal power (electricity) of the heat pump.\n# - `electricity_from`: The `Node` that this heat pump is connected to for electricity input.\n# - `heat_from`: The `Node` that this heat pump is connected to for heat input.\n# - `heat_to`: The `Node` that this heat pump is connected to for heat output.\n# - `cop`: The coefficient of performance of the heat pump.\n\n# ## Components\n# _to be added_\n\n# ## Usage\n# _to be added_\n\n# ## Details\n# _to be added_\n\nparameters:\n  p_nom: null\n  p_nom_max: null\n  electricity_from: null\n  heat_from: null\n  heat_to: null\n  cop: null\n  _inputs: null\n  _conversion: null\n  _capacity: null\n  _invest: null\n\ncomponents:\n  unit:\n    type: Unit\n    inputs: <_inputs>\n    outputs: {heat: <heat_to>}\n    conversion: <_conversion>\n    capacity: <_capacity> in:electricity\n    \n  decision:\n    type: Decision\n    enabled: <_invest>\n    lb: <p_nom>\n    ub: <p_nom_max>\n\nfunctions:\n  validate: |\n    # Check if `p_nom` is non-negative.\n    @check get(\"p_nom\") isa Number\n    @check get(\"p_nom\") >= 0\n\n    # Check if the `Node` parameters are `String`s, where `heat_from` may also be `nothing`.\n    @check get(\"electricity_from\") isa String\n    @check get(\"heat_from\") isa String || isnothing(get(\"heat_from\"))\n    @check get(\"heat_to\") isa String\n\n    # Check if `cop` is positive.\n    @check get(\"cop\") isa Number\n    @check get(\"cop\") > 0\n\n    # Check if `p_nom_max` is either `nothing` or at least `p_nom`.\n    @check isnothing(get(\"p_nom_max\")) || (get(\"p_nom_max\") isa Number && get(\"p_nom_max\") >= get(\"p_nom\"))\n  prepare: |\n    # Determine if investment should be enabled, and set the parameter (used to enable `decision`).\n    invest = !isnothing(get(\"p_nom_max\")) && get(\"p_nom_max\") > get(\"p_nom\")\n    self = get(\"self\")\n\n    set(\"_invest\", invest)\n    if invest\n        # Set the capacity to the size of the decision variable.\n        set(\"_capacity\", \"$(self).decision:value\")\n    else\n        # Set the capacity to the value of `p_nom`.\n        set(\"_capacity\", get(\"p_nom\"))\n    end\n\n    # Prepare some helper variables to make the code afterwards more readable.\n    elec_from = get(\"electricity_from\")\n    heat_from = get(\"heat_from\")\n    cop = get(\"cop\")\n\n    # Handle the optional `heat_from` parameter.\n    if isnothing(heat_from)\n        # If `heat_from` is not specified, we just use electricity as input.\n        set(\"_inputs\", \"{electricity: $(elec_from)}\")\n        set(\"_conversion\", \"1 electricity -> $(cop) heat\")\n    else\n        # If `heat_from` is specified, we now have to account for two inputs.\n        set(\"_inputs\", \"{electricity: $(elec_from), heat: $(heat_from)}\")\n        set(\"_conversion\", \"1 electricity + $(cop - 1) heat -> $(cop) heat\")\n    end","category":"page"},{"location":"pages/tutorials/templates_1/#Next-steps","page":"Templates: Part I","title":"Next steps","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"While the above template is already quite powerful, it can become hard to maintain and understand if it grows too large. In the next tutorial, we will cover how to separate the functions part of the template into a separate file, and later will see how this approach can then be extended even further (a concept that we call Addons), which allows intercepting steps of the model build process.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"But ... before we go there, let's start \"small\". Check out the section Templates: Part II, where we walk through the process of \"out-sourcing\" the functions part of the template.","category":"page"},{"location":"pages/changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"pages/changelog/#[1.0.5]-2024-09-11","page":"Changelog","title":"[1.0.5] - 2024-09-11","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Bug fixes in custom objective building, and better exception handling for log files.","category":"page"},{"location":"pages/changelog/#[1.0.4]-2024-07-26","page":"Changelog","title":"[1.0.4] - 2024-07-26","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Migrate full core component parameter docstrings.","category":"page"},{"location":"pages/changelog/#[1.0.3]-2024-06-18","page":"Changelog","title":"[1.0.3] - 2024-06-18","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Relax version requirements on IESoptLib to include all v0.2.z versions.","category":"page"},{"location":"pages/changelog/#[1.0.2]-2024-06-10","page":"Changelog","title":"[1.0.2] - 2024-06-10","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Fix solver setup for various workflows.","category":"page"},{"location":"pages/changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"IESoptLib and HiGHS are again required dependencies.","category":"page"},{"location":"pages/changelog/#[1.0.1]-2024-06-09","page":"Changelog","title":"[1.0.1] - 2024-06-09","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Added extensions to properly handle loading IESoptLib and various solvers.","category":"page"},{"location":"pages/changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"IESoptLib and HiGHS are no longer required dependencies.","category":"page"},{"location":"pages/changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Dynamic loading of weakdeps now works properly.","category":"page"},{"location":"pages/changelog/#[1.0.0]-2024-06-01","page":"Changelog","title":"[1.0.0] - 2024-06-01","text":"","category":"section"},{"location":"pages/changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Initial public release of IESopt.jl","category":"page"},{"location":"pages/manual___reference/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"This contains the following raw documentation entries:","category":"page"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 2:4","category":"page"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"","category":"page"},{"location":"pages/manual___reference/api/#Julia","page":"API","title":"Julia","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"CurrentModule       = IESopt\nCollapsedDocStrings = true","category":"page"},{"location":"pages/manual___reference/api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"IESopt","category":"page"},{"location":"pages/manual___reference/api/#IESopt.IESopt","page":"API","title":"IESopt.IESopt","text":"IESopt\n\nA general purpose solver agnostic energy system optimization framework.\n\n\n\n\n\n","category":"module"},{"location":"pages/manual___reference/api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"Carrier\nSnapshot","category":"page"},{"location":"pages/manual___reference/api/#IESopt.Carrier","page":"API","title":"IESopt.Carrier","text":"struct Carrier\n    name::String\n    unit::Union{String, Nothing}\nend\n\nRepresents a single (energy) carrier with a given name.\n\nThis is mostly used to represent various commodities that (easily) represent some form of energy (e.g. gas, water, ...), but also enables modelling commodities that are not (treated as) representing some type of energy (e.g. CO2). Specify unit to bind that carrier to an (arbitrary) unit that allows easier plotting and result analysis.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Snapshot","page":"API","title":"IESopt.Snapshot","text":"struct Snapshot\n    name::_String\n    id::_ID\n    weight::_ScalarInput\n\n    is_representative::Bool\n    representative::_ID\nend\n\nRepresent a specific timestamp, that can be tied to timeseries values.\n\nEach Snapshot expects a name, that can be used to hold a timestamp (as String; therefore supporting arbitrary formats). The weight (default = 1.0) specifies the \"probabilistic weight\" of this Snapshot or the length of the timeperiod that begins there (a weight of 2 can therefore represent a 2-hour-resolution; this also allows a variable temporal resolution throughout the year/month/...).\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"Connection\nDecision\nNode\nProfile\nUnit","category":"page"},{"location":"pages/manual___reference/api/#IESopt.Connection-pages-manual___reference-api","page":"API","title":"IESopt.Connection","text":"A Connection is used to model arbitrary flows of energy between Nodes. It allows for limits, costs, delays, ...\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Decision-pages-manual___reference-api","page":"API","title":"IESopt.Decision","text":"A Decision represents a basic decision variable in the model that can be used as input for various other core component's settings, as well as have associated costs.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Node-pages-manual___reference-api","page":"API","title":"IESopt.Node","text":"A Node represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems). It enforces a nodal balance equation (= \"energy that flows into it must flow out\") for every Snapshot. Enabling the internal state of the Node allows it to act as energy storage, modifying the nodal balance equation. This allows using Nodes for various storage tasks (like batteries, hydro reservoirs, heat storages, ...). \n\ndetails: Basic Examples\nA Node that represents an electrical bus:bus:\n  type: Node\n  carrier: electricityA Node that represents a simplified hydrogen storage:store:\n  type: Node\n  carrier: hydrogen\n  has_state: true\n  state_lb: 0\n  state_ub: 50\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Profile-pages-manual___reference-api","page":"API","title":"IESopt.Profile","text":"A Profile allows representing \"model boundaries\" - parts of initial problem that are not endogenously modelled - with a support for time series data. Examples are hydro reservoir inflows, electricity demand, importing gas, and so on. Besides modelling fixed profiles, they also allow different ways to modify the value endogenously.\n\ndetails: Basic Examples\nA Profile that depicts a fixed electricity demand:demand_XY:\n  type: Profile\n  carrier: electricity\n  node_from: grid\n  value: demand_XY@input_fileA Profile that handles cost of fuel:fuel_gas:\n  type: Profile\n  carrier: gas\n  node_to: country_gas_grid\n  mode: create\n  cost: 100.0A Profile that handles CO2 emission costs:co2_cost:\n  type: Profile\n  carrier: co2\n  node_from: total_co2\n  mode: destroy\n  cost: 150.0A Profile that handles selling electricity:sell_electricity:\n  type: Profile\n  carrier: electricity\n  node_from: internal_grid_node\n  mode: destroy\n  cost: -30.0\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Unit-pages-manual___reference-api","page":"API","title":"IESopt.Unit","text":"A Unit allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.\n\ndetails: Basic Examples\nA Unit that represents a basic gas turbine:gas_turbine:\n  type: Unit\n  inputs: {gas: gas_grid}\n  outputs: {electricity: node, co2: total_co2}\n  conversion: 1 gas -> 0.4 electricity + 0.2 co2\n  capacity: 10 out:electricityA Unit that represents a basic wind turbine:wind_turbine:\n  type: Unit\n  outputs: {electricity: node}\n  conversion: ~ -> 1 electricity\n  capacity: 10 out:electricity\n  availability_factor: wind_factor@input_data\n  marginal_cost: 1.7 per out:electricityA Unit that represents a basic heat pump, utilizing a varying COP:heatpump:\n  type: Unit\n  inputs: {electricity: grid}\n  outputs: {heat: heat_system}\n  conversion: 1 electricity -> cop@inputfile heat\n  capacity: 10 in:electricity\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"run\ngenerate!\noptimize!","category":"page"},{"location":"pages/manual___reference/api/#IESopt.run","page":"API","title":"IESopt.run","text":"run(filename::String; kwargs...)\n\nBuild, optimize, and return a model.\n\nArguments\n\nfilename::String: The path to the top-level configuration file.\n\nKeyword Arguments\n\nKeyword arguments are passed to the normpath(__dir, ! function.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.generate!","page":"API","title":"IESopt.generate!","text":"generate!(filename::String; @nospecialize(kwargs...))\n\nGenerate an IESopt model based on the top-level config in filename.\n\nArguments\n\nfilename::String: The name of the file to load.\n\nKeyword Arguments\n\nTo be documented.\n\nReturns\n\nmodel::JuMP.Model: The generated IESopt model.\n\n\n\n\n\ngenerate!(model::JuMP.Model, filename::String; kwargs...)\n\nGenerates an IESopt model from a given file and attaches an optimizer if necessary.\n\nArguments\n\nmodel::JuMP.Model: The JuMP model to be used.\nfilename::String: The path to the file containing the model definition.\n\nKeyword Arguments\n\nTo be documented.\n\nReturns\n\nmodel::JuMP.Model: The generated IESopt model.\n\nNotes\n\nThe function validates the file before parsing and building the model.\nIf the model is not in DIRECT mode and has no optimizer attached, an optimizer is attached.\nThe function logs the model generation process and handles any exceptions that occur during generation.\nIf an error occurs, detailed debug information and the stack trace are logged.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.optimize!","page":"API","title":"IESopt.optimize!","text":"optimize!(model::JuMP.Model; kwargs...)\n\nOptimize the given IESopt model with optional keyword arguments.\n\nArguments\n\nmodel::JuMP.Model: The IESopt model to be optimized.\nkwargs...: Additional keyword arguments to be passed to the JuMP.optimize! function.\n\nDescription\n\nThis function performs the following steps:\n\nIf there are constraint safety penalties, it relaxes the constraints based on these penalties.\nSets the verbosity of the solver output based on the model's configuration.\nLogs the solver output to a file if logging is enabled and supported by the solver.\nCalls JuMP.optimize! to solve the model.\nChecks the result count and termination status to log the optimization outcome.\nAnalyzes the constraint safety results if there were any constraint safety penalties.\nExtracts and saves the results if the model is solved and feasible.\nProfiles the results after optimization.\n\nLogging\n\nLogs messages about the relaxation of constraints, solver output, and optimization status.\nLogs warnings if the safety constraint feature is triggered or if unexpected result counts are encountered.\nLogs errors if the solver log file setup fails, if no results are returned, or if extracting results is not possible.\n\nReturns\n\nnothing: This function does not return any value.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"get_component","category":"page"},{"location":"pages/manual___reference/api/#IESopt.get_component","page":"API","title":"IESopt.get_component","text":"function get_component(model::JuMP.Model, component_name::AbstractString)\n\nGet the component component_name from model.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"compute_IIS","category":"page"},{"location":"pages/manual___reference/api/#IESopt.compute_IIS","page":"API","title":"IESopt.compute_IIS","text":"function compute_IIS(model::JuMP.Model; filename::String = \"\")\n\nCompute the IIS and print it. If filename is specified it will instead write all constraints to the given file. This will fail if the solver does not support IIS computation.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"overview\npack\nunpack","category":"page"},{"location":"pages/manual___reference/api/#IESopt.overview","page":"API","title":"IESopt.overview","text":"overview(file::String)\n\nExtracts the most important information from an IESopt model file, and returns it as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.pack","page":"API","title":"IESopt.pack","text":"pack(file::String; out::String=\"\", method=:store)\n\nPacks the IESopt model specified by the top-level config file file into single file.\n\nThe out argument specifies the output file name. If not specified, a temporary file is created. Returns the output file name. The method argument specifies the compression method to use. The default is :store, which means no compression is used. The other option is :deflate, which uses the DEFLATE compression method. The default (:auto) applies :store to all files below 1 MB, :deflate otherwise.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.unpack","page":"API","title":"IESopt.unpack","text":"unpack(file::String; out::String=\"\", force_overwrite::Bool=false)\n\nUnpacks the IESopt model specified by file.\n\nThe out argument specifies the output directory. If not specified, a temporary directory is created. Returns the path to the top-level config file. The force_overwrite argument specifies whether to overwrite existing files.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#Python","page":"API","title":"Python","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"To be added.","category":"page"},{"location":"#IESopt.jl","page":"Home","title":"IESopt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integrated Energy System Optimization framework written in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IESopt.jl is the core of the IESopt framework, developed at AIT Austrian Institute of Technology GmbH. It is written in Julia, and uses JuMP package to construct the underlying mathematical optimization models, and to interface with various solvers. The model is designed to be modular, and allows for easy extension and customization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out the following GitHub repositories for more information:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IESopt.jl, the core model (a Julia package).\niesopt, the Python interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"danger: Merging documentations\nWe are currently merging this documentation into the (now) central one, over at working iesopt. Besides migrating everything, this requires some clean-up of (potentially) confindential left-overs (e.g., from projects), so the documentation needs to be checked page-by-page. If you are trying to get started before we manage to fix everything, get in touch with us directly - we'll help you set up everything you need.","category":"page"},{"location":"pages/dev_docs/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following sections provide rough guidelines on how to work with IESopt, and mostly IESopt.jl, improving the documentation, testing, and implementing new features.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"info: Helping out\nLooking for things to contribute, with a low entry barrier (besides any open issue)? Check for To be added (especially in the documentation), or TODO (especially in the code).","category":"page"},{"location":"pages/dev_docs/#Getting-started","page":"Developer Documentation","title":"Getting started","text":"","category":"section"},{"location":"pages/dev_docs/#General","page":"Developer Documentation","title":"General","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Install Julia.\nInstall VSCode, and some extensions (this step is optional, but highly recommended).\nClone/fork the repository.\nHappy coding (... see below)!","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"If you are new to Julia, or not entirely sure how everything works - let's talk. We are happy to help you get started, and to guide you through the process. Stuff like Revise.jl can be a huge help, and we can show you how to use it. Further, if you are coming from, e.g., a standard Python background, the advantages of a dynamic REPL-driven development may be new to you.","category":"page"},{"location":"pages/dev_docs/#Tips-and-tricks","page":"Developer Documentation","title":"Tips and tricks","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Check out Modern Julia Workflows.\nCheck out the Julia Discourse.\nRead up details on Revise usage.","category":"page"},{"location":"pages/dev_docs/#Architecture","page":"Developer Documentation","title":"Architecture","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"See ARCHITECTURE.md for more information.","category":"page"},{"location":"pages/dev_docs/#Coding-conventions","page":"Developer Documentation","title":"Coding conventions","text":"","category":"section"},{"location":"pages/dev_docs/#Branches","page":"Developer Documentation","title":"Branches","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We mainly use a \"feature branch workflow\", similar to \"trunk based development\". We strive to keep the main branch as clean as possible (docs and tests should build and pass), and work on a separate development (trunk) branch. For larger changes, consider starting new feature branches. Where possible we use PRs (or merge requests) to get changes into the main branch, while doing a (light) code review for each other.","category":"page"},{"location":"pages/dev_docs/#Naming-conventions","page":"Developer Documentation","title":"Naming conventions","text":"","category":"section"},{"location":"pages/dev_docs/#Julia","page":"Developer Documentation","title":"Julia","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We make use of the following naming conventions, which slightly differ from the Julia naming conventions, but are similar to other large projects out there:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Types and similar items use CamelCase, e.g., MyType.\nFunctions and variables use snake_case, e.g., my_function(...).\nFunctions that modify their arguments should end with an exclamation mark, e.g., optimize!(...).\nFunctions and variables should actually make use of underscores, whenever reasonable (and not only when absolutely necessary), e.g., set_to_zero!(...) (not settozero!(...) like the Julia naming conventions may suggest).\nConstants are written in UPPERCASE, e.g., MY_CONSTANT.","category":"page"},{"location":"pages/dev_docs/#Python","page":"Developer Documentation","title":"Python","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"To be added (black with --line-length 88, ruff, standard naming conventions, ...).","category":"page"},{"location":"pages/dev_docs/#Conventional-commits","page":"Developer Documentation","title":"Conventional commits","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Refer to the Conventional Commits specification for a detailed explanation. In short, we use the following format:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"feat: implemented new feature X\nfix: fixed the bug X\nrefactor: refactored the code X\ndocs: updated the documentation X\ntest: added a new test for X\nchore: updated the dependencies X","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"As indicated we use docs, but test (and not tests), which can be remembered by looking at the folder names: docs/ and test/.","category":"page"},{"location":"pages/dev_docs/#Version-numbers","page":"Developer Documentation","title":"Version numbers","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Documenter.jl (as of May, 22nd, 2024) aggressively states: \"Documenter, like any good Julia package, follows semantic versioning (SemVer).\"","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Unfortunately, semantic versioning may not be as well suited as one might think for a package like IESopt.jl. Some reasons are:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"While the (Julia) API has been stable for a long time (in a sense of: backwards-compatible), we consider the YAML configuration syntax as main part of IESopt's \"API\". This syntax has changed multiple times, and will likely change in the future. Maintaining full backwards compatibility for this is not feasible all the time. This induces a need for a major version bump, even though the Julia API has not changed.\nA mere bug fix, even a small one, in IESopt.jl may very likely induce changed results of any model run. A user could see vastly different results between v1.3.10 and v1.3.11, even though the changes are minimal. This involves not taking patch updates lightly, which is not the case in many other packages.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"However, as indicated, the use of semantic versioning is still \"expected\" by large parts of the Julia community, and not doing so may make it harder for some users, and/or some interactions with other packages. So...","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"IESopt.jl makes use of semantic versioning!\nYou are advised to consider the above points when deciding on version bumps.\nAdvise users and make sure you properly document changes.\nExpect rising major version numbers.","category":"page"},{"location":"pages/dev_docs/#Working-with-VSCode","page":"Developer Documentation","title":"Working with VSCode","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following set of extensions may be helpful, either for development or documentation purposes:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Julia\nLive Preview\nMarkdown Julia\nMarkdown Preview GitHub Styling\nmarkdownlint\nRainbow CSV","category":"page"},{"location":"pages/dev_docs/#Improving-the-documentation","page":"Developer Documentation","title":"Improving the documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"# TODO: refactor to new syntax: `julia --project=. -e 'include(\"docs/liveserver.jl\")'`","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Docstrings of public entries of IESopt.jl are taken from the code, see src/.... Besides that, the documentation is contained in the docs/src/... folder, and built based on docs/make.jl, using Documenter.jl.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"info: Diátaxis\nConsider checking out the excellent \"project\" Diátaxis, by Daniele Procida. We try to adhere to the principles outlined there, and you may find them useful as well. For a quick intro, you may consider starting here: The difference between a tutorial and how-to guide.","category":"page"},{"location":"pages/dev_docs/#Setup","page":"Developer Documentation","title":"Setup","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Make sure that you","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"have a working installation of Julia (otherwise go to julialang.org and install it; we recommend sticking to Juliaup if asked), and\nhave a terminal of your choice launched at IESopt.jl/.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Then, run the following command once to set up the environment used for the documentation:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"julia --project=docs -e 'import Pkg; Pkg.instantiate()'","category":"page"},{"location":"pages/dev_docs/#Building-the-documentation","page":"Developer Documentation","title":"Building the documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Launch an interactive web server that shows you the documentation while you are working on it:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"julia --project=docs -e 'using LiveServer; servedocs(; launch_browser=true)'","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Note: While the above is your best choice in 95% of all cases, you can also manually build the documentation usingjulia --project=docs docs/make.jlwhich may be useful if you modify source files (which LiveServer.jl currently does not track in a convenient way). Note however that this will not automatically reload the documentation in your browser (but may in VSCode if you right-click the index.html file and select Preview, using the Live Preview extension), and may fail to properly account for image/... paths.","category":"page"},{"location":"pages/dev_docs/#Code-formatting","page":"Developer Documentation","title":"Code formatting","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We provide a custom .JuliaFormatter.toml file that should be used to format the code. The easiest way to use it is to:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Add JuliaFormatter to your Julia base environment by running ] add JuliaFormatter in the package mode of your Julia REPL (without an active IESopt environment).\nRun using JuliaFormatter in the Julia REPL (this now works even if you activated the IESopt environment).\nRun format(\".\") in the Julia REPL to format all files in your current directory. This takes a bit of compile time, but after the first run, it should be fairly fast.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Make sure you checked the formatting, before finalizing your changes or opening a PR. If you forgot to include formatting in your actual commits (we all do...), and cannot reasonably amend them, add all formatting changes at the end in a single commit with the message:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"git commit -m \"chore: formatting\"","category":"page"},{"location":"pages/dev_docs/#Testing","page":"Developer Documentation","title":"Testing","text":"","category":"section"},{"location":"pages/dev_docs/#Running-tests-locally","page":"Developer Documentation","title":"Running tests locally","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Launch a new Julia REPL (hit Alt+J and then Alt+O in VSCode), enter Package mode (by pressing ] in your REPL, now showing (IESopt) pkg>), and then execute all tests by running:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"(IESopt) pkg> test","category":"page"},{"location":"pages/manual___reference/core_components/#Model-formulation","page":"Model formulation","title":"Model formulation","text":"","category":"section"},{"location":"pages/manual___reference/core_components/","page":"Model formulation","title":"Model formulation","text":"This page collects all information about the core components of IESopt, their properties (and default values), their internal mathematical formulations, and some examples of how to use them. See the API for a complete list of all available functions and types.","category":"page"},{"location":"pages/manual___reference/core_components/","page":"Model formulation","title":"Model formulation","text":"CurrentModule       = IESopt\nCollapsedDocStrings = true","category":"page"},{"location":"pages/manual___reference/core_components/","page":"Model formulation","title":"Model formulation","text":"Connection\nDecision\nNode\nProfile\nUnit","category":"page"},{"location":"pages/manual___reference/core_components/#IESopt.Connection","page":"Model formulation","title":"IESopt.Connection","text":"A Connection is used to model arbitrary flows of energy between Nodes. It allows for limits, costs, delays, ...\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Decision","page":"Model formulation","title":"IESopt.Decision","text":"A Decision represents a basic decision variable in the model that can be used as input for various other core component's settings, as well as have associated costs.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Node","page":"Model formulation","title":"IESopt.Node","text":"A Node represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems). It enforces a nodal balance equation (= \"energy that flows into it must flow out\") for every Snapshot. Enabling the internal state of the Node allows it to act as energy storage, modifying the nodal balance equation. This allows using Nodes for various storage tasks (like batteries, hydro reservoirs, heat storages, ...). \n\ndetails: Basic Examples\nA Node that represents an electrical bus:bus:\n  type: Node\n  carrier: electricityA Node that represents a simplified hydrogen storage:store:\n  type: Node\n  carrier: hydrogen\n  has_state: true\n  state_lb: 0\n  state_ub: 50\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Profile","page":"Model formulation","title":"IESopt.Profile","text":"A Profile allows representing \"model boundaries\" - parts of initial problem that are not endogenously modelled - with a support for time series data. Examples are hydro reservoir inflows, electricity demand, importing gas, and so on. Besides modelling fixed profiles, they also allow different ways to modify the value endogenously.\n\ndetails: Basic Examples\nA Profile that depicts a fixed electricity demand:demand_XY:\n  type: Profile\n  carrier: electricity\n  node_from: grid\n  value: demand_XY@input_fileA Profile that handles cost of fuel:fuel_gas:\n  type: Profile\n  carrier: gas\n  node_to: country_gas_grid\n  mode: create\n  cost: 100.0A Profile that handles CO2 emission costs:co2_cost:\n  type: Profile\n  carrier: co2\n  node_from: total_co2\n  mode: destroy\n  cost: 150.0A Profile that handles selling electricity:sell_electricity:\n  type: Profile\n  carrier: electricity\n  node_from: internal_grid_node\n  mode: destroy\n  cost: -30.0\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Unit","page":"Model formulation","title":"IESopt.Unit","text":"A Unit allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.\n\ndetails: Basic Examples\nA Unit that represents a basic gas turbine:gas_turbine:\n  type: Unit\n  inputs: {gas: gas_grid}\n  outputs: {electricity: node, co2: total_co2}\n  conversion: 1 gas -> 0.4 electricity + 0.2 co2\n  capacity: 10 out:electricityA Unit that represents a basic wind turbine:wind_turbine:\n  type: Unit\n  outputs: {electricity: node}\n  conversion: ~ -> 1 electricity\n  capacity: 10 out:electricity\n  availability_factor: wind_factor@input_data\n  marginal_cost: 1.7 per out:electricityA Unit that represents a basic heat pump, utilizing a varying COP:heatpump:\n  type: Unit\n  inputs: {electricity: grid}\n  outputs: {heat: heat_system}\n  conversion: 1 electricity -> cop@inputfile heat\n  capacity: 10 in:electricity\n\n\n\n\n\n","category":"type"}]
}
