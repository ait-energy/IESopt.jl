var documenterSearchIndex = {"docs":
[{"location":"pages/tutorials/templates_1/#Templates:-Part-I","page":"Templates: Part I","title":"Templates: Part I","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Templates are a powerful feature of IESopt that allow you to define new types of \"components\" by yourself. This makes use of the existing CoreComponents, and combines them in multiple ways, which allows for a high degree of flexibility without having to write any mathematical model yourself.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"This tutorial will guide you through the process of creating a new template, and we will do that on the example of creating the HeatPump template.","category":"page"},{"location":"pages/tutorials/templates_1/#The-basic-structure","page":"Templates: Part I","title":"The basic structure","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"A template is defined by a YAML file, similar to the config.iesopt.yaml file that you already know. First, we need to think about the parameters that we want to define for our heat pump. Let's create a new file for that. The pre-defined one is called HeatPump, so we need a different name: Templates must always have a unique name.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Possibilities for that could be:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"CustomHeatPump, if you do not have any more details\nGroundSourceHeatPump, if we want to implement a ground-source heat pump with different parameters/features than the standard one\nFooHeatPump, if you need it specifically for a project called \"Foo\"","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"info: Naming conventions\nTemplates follow a naming convention similar to PascalCase:The name must start with an upper-case letter\nIt must consist of at least two letters\nNumbers and special characters are not allowed","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's go with CustomHeatPump for now. Create a new file CustomHeatPump.iesopt.template.yaml (if you are already working on a model, the best place to put this would be a templates/ folder), and add the following lines:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"parameters:\n  p_nom: null\n  electricity_from: null\n  heat_from: null\n  heat_to: null\n  cop: null","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"This defines the basic parameters that we want to use for our heat pump. The null values indicate that they all default to nothing in Julia, which corresponds to None in Python. Let's go through them:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"p_nom: The nominal power of the heat pump, which will be specified on the electricity input side\nelectricity_from: The Node that this heat pump is connected to for electricity input\nheat_from: The Node that this heat pump is connected to for heat input\nheat_to: The Node that this heat pump is connected to for heat output\ncop: The coefficient of performance of the heat pump","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Next, we will set up the actual component. This is done in the component section of the template file. Let's add the following lines:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"component:\n  type: Unit\n  inputs: {electricity: <electricity_from>, heat: <heat_from>}\n  outputs: {heat: <heat_to>}\n  conversion: 1 electricity + (<cop> - 1) heat -> <cop> heat\n  capacity: <p_nom> in:electricity","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"This defines the component that we want to create. The type is Unit, which is a core component type in IESopt that you are already familiar with. Instead of providing fixed values, we make use of the parameters that we defined above. This is done by using the <...> syntax.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"That's it! You have created a new template. You can now use this template in your model configuration, as you would with any other component. For example, you could add the following lines to your config.iesopt.yaml file:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"# other parts of the configuration file\n# ...\n\ncomponents:\n  # some other components\n  # ...\n\n  heat_pump:\n    template: CustomHeatPump\n    parameters:\n      p_nom: 10\n      electricity_from: electricity\n      heat_from: ambient\n      heat_to: heating\n      cop: 3","category":"page"},{"location":"pages/tutorials/templates_1/#Accounting-for-different-configurations","page":"Templates: Part I","title":"Accounting for different configurations","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"But wait. What if you want to have different configurations for your heat pump? For example, you might want to have a heat pump that does not explicitly consume any heat, because they low-temperature heat source is not explicitly modeled. Currently, the template does not allow for that, because the heat_from parameter is mandatory.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Why do we know it is mandatory? Because it is used in the inputs section of the Unit definition. But that is not clear, or transparent. Before we continue, we will fill in the mandatory documentation fields for the template. We do that by adding the following information directly at the beginning of the template file, right before the parameters:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"# # Custom Heat Pump\n\n# A (custom) heat pump that consumes electricity and heat, and produces heat.\n\n# ## Parameters\n# - `p_nom`: The nominal power (electricity) of the heat pump.\n# - `electricity_from`: The `Node` that this heat pump is connected to for electricity input.\n# - `heat_from`: The `Node` that this heat pump is connected to for heat input.\n# - `heat_to`: The `Node` that this heat pump is connected to for heat output.\n# - `cop`: The coefficient of performance of the heat pump.\n\n# ## Components\n# _to be added_\n\n# ## Usage\n# _to be added_\n\n# ## Details\n# _to be added_\n\nparameters:\n  # ...","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"info: Docstring format\nAll of that is actually just Markdown inserted into your template. However, make sure to stick to separating the leading # from the actual text by a space, as this is required for IESopt to better understand your documentation.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Now, every user of the template will see this information, and they will notice, that none of the parameters are marked as optional. As you see, there are a lot of other sections to be added, but we will fill them out at the end, after we have finished the template, see the section on finalizing the docstring.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's continue with accounting for different configurations. We will cover the following steps:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Making the heat_from parameter optional\nExtending the template to allow for sizing the heat pump (an investment decision)\nHandling more complex COP configurations","category":"page"},{"location":"pages/tutorials/templates_1/#Optional-parameter-and-sizing-decision","page":"Templates: Part I","title":"Optional parameter and sizing decision","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"While there are multiple ways to make a parameter optional, we will make use of the most powerful one, so that you are able to apply it for your models as well. For that, we will add \"complex\" functionalities to the template, which is done using three different \"functions\":","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"validate: This function is called when the template is parsed, and it is used to check if the parameters are valid. If they are not, an error is thrown. This helps to inform the user of any misconfiguration.\nprepare: This function is called when the template is instantiated, and it is used to prepare the component for usage. This can be used to set default values, or to calculate derived parameters (which we will use to tackle the three additions mentioned above).\nfinalize: This function is called when the template is finalized, and it enables a wide range of options. We will  use this to allow a smooth result extraction for the heat pump, but you could also use it to add additional (more  complex) constraints to the component, or even modify the model's objective function.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's start by adding the functions entry (which we suggest doing at the end of the file):","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"# ... the whole docstring ...\n\nparameters:\n  # ...\n\ncomponent:\n  # ...\n\nfunctions:\n  validate: |\n    # ... we will put the validation code here ...\n  prepare: |\n    # ... we will put the preparation code here ...\n  finalize: |\n    # ... we will put the finalization code here ...","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"The | at the end of the line indicates that the following lines are a multiline string. This is a YAML feature that allows you to write more complex code in a more readable way.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's start by filling out the validation function. Everything you do and write here, is interpreted as Julia code, and compiled directly into your model. This means that you can use all the power of Julia, but also that you need to be careful with what you do. You have access to certain helper functions and constants, which we will introduce here. If you have never written a line of Julia code, don't worry. We will guide you through this - it's actually (at least for the parts that you will need) extremely similar to Python.","category":"page"},{"location":"pages/tutorials/templates_1/#Validation","page":"Templates: Part I","title":"Validation","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"The validation function is used to check if the parameters are valid. Add the following code to the validate section:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"functions:\n  validate: |\n    # Check if `p_nom` is non-negative.\n    @check get(\"p_nom\") isa Number\n    @check get(\"p_nom\") >= 0\n\n    # Check if the `Node` parameters are `String`s, where `heat_from` may also be `nothing`.\n    @check get(\"electricity_from\") isa String\n    @check get(\"heat_from\") isa String || isnothing(get(\"heat_from\"))\n    @check get(\"heat_to\") isa String\n\n    # Check if `cop` is positive.\n    @check get(\"cop\") isa Number\n    @check get(\"cop\") > 0\n  # ... the rest of the template ...","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Let's go through this step by step:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"You can start comments (as separate line or inline) with #, as you would in Python.\nYou can use get(\"some_param\") to access the value of a parameter.\nYou can use @check to check if a condition is met. If it is not, an error will be thrown. All statements starting with @ are so called \"macros\", which are just \"special\" functions. You can do @check(condition) or @check condition, since macros do not require parentheses.\nYou can use isa to check if a value is of a certain type. This is similar to isinstance in Python. While it is a special keyword, if you prefer, you can also call it in a more conventional way: isa(get(\"p_nom\"), Number).\nData types are capitalized in Julia, so it is String instead of string, and Number is a superset of all numeric types (if necessary you could instead, e.g., check for get(\"some_param\") isa Int).\nLogical operators are similar to Python, so || is like or, and && is like and.\nIf all checks pass, the template is considered valid, and the model can be built.","category":"page"},{"location":"pages/tutorials/templates_1/#Preparation","page":"Templates: Part I","title":"Preparation","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Next, we will add the preparation function. This function is used to prepare the component for usage. Since we would like to make the heat_from parameter optional, and we would like to account for optional sizing, we will first modify the parameters accordingly:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"parameters:\n  p_nom: null\n  p_nom_max: null\n  electricity_from: null\n  heat_from: null\n  heat_to: null\n  cop: null\n  _inputs: null\n  _conversion: null\n  _capacity: null\n  _invest: null","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"One step at a time. We added the following parameters:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"p_nom_max: The maximum nominal power of the heat pump. This is optional, and if not specified, it will default to p_nom, which will disable the sizing feature.\n_inputs: This is an internal / private parameter (since it starts with an underscore), which we will user later. These parameters are not exposed to the user, and can not be set or modified from the outside.\n_capacity: This is another internal parameter, which we will use to store the capacity of the heat pump (which could now either bne p_nom or whatever the investment decision results in).\n_conversion: This is another internal parameter, which we will use to store the conversion formula.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Before we can actually add the code for the prepare function, we need to modify our component definition, as well. We (1) will change from component to components (since it now contains more than just one), (2) will add a Decision that should handle the sizing / investment, and modify the Unit slightly:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"components:\n  unit:\n    type: Unit\n    inputs: <_inputs>\n    outputs: {heat: <heat_to>}\n    conversion: <_conversion>\n    capacity: <_capacity> in:electricity\n  \n  decision:\n    type: Decision\n    enabled: <_invest>\n    lb: <p_nom>\n    ub: <p_nom_max>","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"So ... a lot of changes. Let's go through them step by step:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"We changed component to components, because we now have multiple components.\nWe added a unit component, which is the actual heat pump. We replaced the fixed values with the internal parameters.\nWe added a new component decision, which is a Decision. This component is used to handle investment decisions. It is enabled if _invest evaluates to true. It has a lower bound lb and an upper bound ub, which are the minimum and maximum values that the decision can take. In our case, the decision is the nominal power of the heat pump, which can be between p_nom and p_nom_max.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"info: Naming the components\nThe names of the components are arbitrary, and you can choose whatever you like. However, it is recommended to use meaningful names, so that you can easily understand what the component does. Component names follow a naming convention similar to snake_case: They must start with a lower-case letter, and can contain numbers and underscores (but are not allowed to end in an _). They can further contain ., but this is \"dangerous\" and an expert feature, that you should not use unless you know what it does, and why you need it.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Onto the actual functionality. Let's add the prepare function, and some additional validation code:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"functions:\n  validate: |\n    # ... the previous validation code ...\n\n    # Check if `p_nom_max` is either `nothing` or at least `p_nom`.\n    @check isnothing(get(\"p_nom_max\")) || (get(\"p_nom_max\") isa Number && get(\"p_nom_max\") >= get(\"p_nom\"))\n  prepare: |\n    # Determine if investment should be enabled, and set the parameter (used to enable `decision`).\n    invest = !isnothing(get(\"p_nom_max\")) && get(\"p_nom_max\") > get(\"p_nom\")\n    self = get(\"self\")\n\n    set(\"_invest\", invest)\n    if invest\n        # Set the capacity to the size of the decision variable.\n        set(\"_capacity\", \"$(self).decision:value\")\n    else\n        # Set the capacity to the value of `p_nom`.\n        set(\"_capacity\", get(\"p_nom\"))\n    end\n\n    # Prepare some helper variables to make the code afterwards more readable.\n    elec_from = get(\"electricity_from\")\n    heat_from = get(\"heat_from\")\n    cop = get(\"cop\")\n\n    # Handle the optional `heat_from` parameter.\n    if isnothing(heat_from)\n        # If `heat_from` is not specified, we just use electricity as input.\n        set(\"_inputs\", \"{electricity: $(elec_from)}\")\n        set(\"_conversion\", \"1 electricity -> $(cop) heat\")\n    else\n        # If `heat_from` is specified, we now have to account for two inputs.\n        set(\"_inputs\", \"{electricity: $(elec_from), heat: $(heat_from)}\")\n        set(\"_conversion\", \"1 electricity + $(cop - 1) heat -> $(cop) heat\")\n    end","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"Once again, let's go through this step by step:","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#Complex-COP-configurations","page":"Templates: Part I","title":"Complex COP configurations","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#The-finalize-function","page":"Templates: Part I","title":"The finalize function","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#Finalizing-the-docstring","page":"Templates: Part I","title":"Finalizing the docstring","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/#Conclusion","page":"Templates: Part I","title":"Conclusion","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"To be added.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"details: Complete template YAML\n# # Custom Heat Pump\n\n# A (custom) heat pump that consumes electricity and heat, and produces heat.\n\n# ## Parameters\n# - `p_nom`: The nominal power (electricity) of the heat pump.\n# - `electricity_from`: The `Node` that this heat pump is connected to for electricity input.\n# - `heat_from`: The `Node` that this heat pump is connected to for heat input.\n# - `heat_to`: The `Node` that this heat pump is connected to for heat output.\n# - `cop`: The coefficient of performance of the heat pump.\n\n# ## Components\n# _to be added_\n\n# ## Usage\n# _to be added_\n\n# ## Details\n# _to be added_\n\nparameters:\n  p_nom: null\n  p_nom_max: null\n  electricity_from: null\n  heat_from: null\n  heat_to: null\n  cop: null\n  _inputs: null\n  _conversion: null\n  _capacity: null\n  _invest: null\n\ncomponents:\n  unit:\n    type: Unit\n    inputs: <_inputs>\n    outputs: {heat: <heat_to>}\n    conversion: <_conversion>\n    capacity: <_capacity> in:electricity\n    \n  decision:\n    type: Decision\n    enabled: <_invest>\n    lb: <p_nom>\n    ub: <p_nom_max>\n\nfunctions:\n  validate: |\n    # Check if `p_nom` is non-negative.\n    @check get(\"p_nom\") isa Number\n    @check get(\"p_nom\") >= 0\n\n    # Check if the `Node` parameters are `String`s, where `heat_from` may also be `nothing`.\n    @check get(\"electricity_from\") isa String\n    @check get(\"heat_from\") isa String || isnothing(get(\"heat_from\"))\n    @check get(\"heat_to\") isa String\n\n    # Check if `cop` is positive.\n    @check get(\"cop\") isa Number\n    @check get(\"cop\") > 0\n\n    # Check if `p_nom_max` is either `nothing` or at least `p_nom`.\n    @check isnothing(get(\"p_nom_max\")) || (get(\"p_nom_max\") isa Number && get(\"p_nom_max\") >= get(\"p_nom\"))\n  prepare: |\n    # Determine if investment should be enabled, and set the parameter (used to enable `decision`).\n    invest = !isnothing(get(\"p_nom_max\")) && get(\"p_nom_max\") > get(\"p_nom\")\n    self = get(\"self\")\n\n    set(\"_invest\", invest)\n    if invest\n        # Set the capacity to the size of the decision variable.\n        set(\"_capacity\", \"$(self).decision:value\")\n    else\n        # Set the capacity to the value of `p_nom`.\n        set(\"_capacity\", get(\"p_nom\"))\n    end\n\n    # Prepare some helper variables to make the code afterwards more readable.\n    elec_from = get(\"electricity_from\")\n    heat_from = get(\"heat_from\")\n    cop = get(\"cop\")\n\n    # Handle the optional `heat_from` parameter.\n    if isnothing(heat_from)\n        # If `heat_from` is not specified, we just use electricity as input.\n        set(\"_inputs\", \"{electricity: $(elec_from)}\")\n        set(\"_conversion\", \"1 electricity -> $(cop) heat\")\n    else\n        # If `heat_from` is specified, we now have to account for two inputs.\n        set(\"_inputs\", \"{electricity: $(elec_from), heat: $(heat_from)}\")\n        set(\"_conversion\", \"1 electricity + $(cop - 1) heat -> $(cop) heat\")\n    end","category":"page"},{"location":"pages/tutorials/templates_1/#Next-steps","page":"Templates: Part I","title":"Next steps","text":"","category":"section"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"While the above template is already quite powerful, it can become hard to maintain and understand if it grows too large. In the next tutorial, we will cover how to separate the functions part of the template into a separate file, and later will see how this approach can then be extended even further (a concept that we call Addons), which allows intercepting steps of the model build process.","category":"page"},{"location":"pages/tutorials/templates_1/","page":"Templates: Part I","title":"Templates: Part I","text":"But ... before we go there, let's start \"small\". Check out the section Templates: Part II, where we walk through the process of \"out-sourcing\" the functions part of the template.","category":"page"},{"location":"pages/changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"pages/changelog/#[1.0.5]-2024-09-11","page":"Changelog","title":"[1.0.5] - 2024-09-11","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Bug fixes in custom objective building, and better exception handling for log files.","category":"page"},{"location":"pages/changelog/#[1.0.4]-2024-07-26","page":"Changelog","title":"[1.0.4] - 2024-07-26","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Migrate full core component parameter docstrings.","category":"page"},{"location":"pages/changelog/#[1.0.3]-2024-06-18","page":"Changelog","title":"[1.0.3] - 2024-06-18","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Relax version requirements on IESoptLib to include all v0.2.z versions.","category":"page"},{"location":"pages/changelog/#[1.0.2]-2024-06-10","page":"Changelog","title":"[1.0.2] - 2024-06-10","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Fix solver setup for various workflows.","category":"page"},{"location":"pages/changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"IESoptLib and HiGHS are again required dependencies.","category":"page"},{"location":"pages/changelog/#[1.0.1]-2024-06-09","page":"Changelog","title":"[1.0.1] - 2024-06-09","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Added extensions to properly handle loading IESoptLib and various solvers.","category":"page"},{"location":"pages/changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"IESoptLib and HiGHS are no longer required dependencies.","category":"page"},{"location":"pages/changelog/#Fixed","page":"Changelog","title":"Fixed","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Dynamic loading of weakdeps now works properly.","category":"page"},{"location":"pages/changelog/#[1.0.0]-2024-06-01","page":"Changelog","title":"[1.0.0] - 2024-06-01","text":"","category":"section"},{"location":"pages/changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Initial public release of IESopt.jl","category":"page"},{"location":"pages/manual___reference/api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"This contains the following raw documentation entries:","category":"page"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"Pages = [\"api.md\"]\nDepth = 2:4","category":"page"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"","category":"page"},{"location":"pages/manual___reference/api/#Julia","page":"API","title":"Julia","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"CurrentModule       = IESopt\nCollapsedDocStrings = true","category":"page"},{"location":"pages/manual___reference/api/#Modules","page":"API","title":"Modules","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"IESopt","category":"page"},{"location":"pages/manual___reference/api/#IESopt.IESopt","page":"API","title":"IESopt.IESopt","text":"IESopt\n\nA general purpose solver agnostic energy system optimization framework.\n\n\n\n\n\n","category":"module"},{"location":"pages/manual___reference/api/#Types","page":"API","title":"Types","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"Carrier\nSnapshot","category":"page"},{"location":"pages/manual___reference/api/#IESopt.Carrier","page":"API","title":"IESopt.Carrier","text":"struct Carrier\n    name::String\n    unit::Union{String, Nothing}\nend\n\nRepresents a single (energy) carrier with a given name.\n\nThis is mostly used to represent various commodities that (easily) represent some form of energy (e.g. gas, water, ...), but also enables modelling commodities that are not (treated as) representing some type of energy (e.g. CO2). Specify unit to bind that carrier to an (arbitrary) unit that allows easier plotting and result analysis.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Snapshot","page":"API","title":"IESopt.Snapshot","text":"struct Snapshot\n    name::_String\n    id::_ID\n    weight::_ScalarInput\n\n    is_representative::Bool\n    representative::_ID\nend\n\nRepresent a specific timestamp, that can be tied to timeseries values.\n\nEach Snapshot expects a name, that can be used to hold a timestamp (as String; therefore supporting arbitrary formats). The weight (default = 1.0) specifies the \"probabilistic weight\" of this Snapshot or the length of the timeperiod that begins there (a weight of 2 can therefore represent a 2-hour-resolution; this also allows a variable temporal resolution throughout the year/month/...).\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"Connection\nDecision\nNode\nProfile\nUnit","category":"page"},{"location":"pages/manual___reference/api/#IESopt.Connection-pages-manual___reference-api","page":"API","title":"IESopt.Connection","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\nnode_from yes string - - This Connection models a flow from node_from to node_to (both are Nodes).\nnode_to yes string - - This Connection models a flow from node_from to node_to (both are Nodes).\ncarrier no string - - Carrier of this Connection. If not given, automatically picks the carrier of the Nodes it connects. This parameter is not necessary, and only exists to allow for a more explicit definition.\ncapacity no numeric, col@file, decision:value power +infty The symmetric bound on this Connection's flow. Results in lb = -capacity and ub = capacity. Must not be specified if lb, ub, or both are explicitly stated.\nlb no numeric, col@file, decision:value power -infty Lower bound of this Connection's flow.\nub no numeric, col@file, decision:value power +infty Upper bound of this Connection's flow.\ncost no numeric monetary (per energy) - Cost of every unit of energy flow over this connection that is added to the model's objective function. Keep in mind that negative flows will induce negative costs, which can be used to model revenues. Further, a bidirectional Connection (if lb < 0, which is the default, or if capacity is used) with a positive cost will lead to negative costs for the reverse flow. If you do not want this, split the Connection into two separate ones, each being unidirectional (with lb: 0). Remember, that these can share the same \"capacity\" (which is then set asub), even when using decision:value or col@file as value.\nloss no in 0 1 - 0 Fractional loss when transferring energy. This loss occurs \"at the destination\", which means that for a loss of 5%, set as loss: 0.05, and considering a Snapshot where the Connection has a flow value of 100, it will \"extract\" 100 from node_from and \"inject\" 95 into node_to. Since the flow variable is given as power, this would, e.g., translate to consuming 200 units of energy at node_from and injecting 190 units at node_to, if the Snapshot duration is 2 hours.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: flow\nnothing\n\nExpressions\n\ndetails: pf_flow\nnothing\n\nConstraints\n\ndetails: flow_bounds\nnothing\n\nObjectives\n\ndetails: cost\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Decision-pages-manual___reference-api","page":"API","title":"IESopt.Decision","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\nlb no numeric - 0 Minimum size of the decision value (considered for each \"unit\" if count allows multiple \"units\").\nub no numeric - +infty Maximum size of the decision value (considered for each \"unit\" if count allows multiple \"units\").\ncost no numeric monetary (per value) 0 Cost that the decision value induces, given as cost cdot value.\nfixed_value no numeric - - If mode: fixed, this value is used as the fixed value of the decision. This can be useful if this Decision was used in a previous optimization and its value should be fixed to that value in the next optimization (applying it where ever it is used, instead of needing to find all usages). Furthermore, this allows extracting the dual value of the constraint that fixes the value, assisting in approaches like Benders decomposition. Note that this does not change the induced cost in any way.\nfixed_cost no - monetary - This setting activates a \"fixed cost\" component for this decision variable, which requires that the model's problem type allows for binary variables (e.g., MILP). This can be used to model fixed costs that are only incurred if the decision variable is active (e.g., a fixed cost for an investment that is only incurred if the investment is made). If the decision is 0, no fixed costs have to be paid; however, if the decision is greater than 0, the fixed cost is incurred. Note that after deciding to activate the decision, the overall value is still determined in the usual (continuous) way, incuring the (variable) cost as well. More complex cost functions can be modelled by switching to mode sos1 or sos2 and using the sos parameter.\nmode no linear, binary, integer, sos1, sos2, fixed - linear Type of the decision variable that is constructed. linear results in a continuous decision, integer results in a integer variable, binary constrains it to be either 0 or 1. sos1 and sos2 can be used to activate SOS1 or SOS2 mode (used for piecewise linear costs). See fixed_value if setting this to fixed.\nsos no list - - TODO (meanwhile, refer to the SOS or PiecewiseLinearCost example).\nbuild_priority no numeric - 1000 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: fixed\nnothing\n\ndetails: sos\nnothing\n\ndetails: value\nnothing\n\nExpressions\n\nConstraints\n\ndetails: fixed\nnothing\n\ndetails: sos1\nnothing\n\ndetails: sos2\nnothing\n\ndetails: sos_value\nnothing\n\nObjectives\n\ndetails: fixed\nnothing\n\ndetails: sos\nnothing\n\ndetails: value\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Node-pages-manual___reference-api","page":"API","title":"IESopt.Node","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\ncarrier yes string - - Carrier of this Node. All connecting components need to respect that.\nhas_state no true, false - false If true, the Node is considered to have an internal state (\"stateful Node\"). This allows it to act as energy storage. Connect Connections or Units to it, acting as charger/discharger.\nstate_lb no numeric, col@file, decision:value energy -infty Lower bound of the internal state, requires has_state = true.\nstate_ub no numeric, col@file, decision:value energy +infty Upper bound of the internal state, requires has_state = true.\nstate_cyclic no eq, geq, or disabled - eq Controls how the state considers the boundary between last and first Snapshot. disabled disables cyclic behaviour of the state (see also state_initial), eq leads to the state at the end of the year being the initial state at the beginning of the year, while geq does the same while allowing the end-of-year state to be higher (= \"allowing to destroy energy at the end of the year\").\nstate_initial no numeric energy - Sets the initial state. Must be used in combination with state_cyclic = disabled.\nstate_final no numeric energy - Sets the final state. Must be used in combination with state_cyclic = disabled.\nstate_percentage_loss no in 0 1 - 0 Per Snapshot percentage loss of state (losing 1% should be set as 0.01).\nnodal_balance no enforce, destroy, or create - enforce Can only be used for has_state = false. enforce forces total injections to always be zero (similar to Kirchhoff's current law), create allows \"supply < demand\", destroy allows \"supply > demand\", at this Node.\nsum_window_size no integer - - TODO.\nsum_window_step no integer - 1 TODO.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: pf_theta\nnothing\n\ndetails: state\nnothing\n\nExpressions\n\ndetails: injection\nnothing\n\nConstraints\n\ndetails: last_state\nnothing\n\ndetails: nodalbalance\nnothing\n\ndetails: state_bounds\nnothing\n\nObjectives\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Profile-pages-manual___reference-api","page":"API","title":"IESopt.Profile","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\ncarrier yes string - - Carrier of this Profile. Must match the Carrier of the Node that this connects to.\nvalue no numeric, col@file power - The concrete value of this Profile - either static or as time series. Only applicable if mode: fixed.\nnode_from no string - - Name of the Node that this Profile draws energy from. Exactly one of node_from and node_to must be set.\nnode_to no string - - Name of the Node that this Profile feeds energy to. Exactly one of node_from and node_to must be set.\nmode no - - fixed The mode of operation of this Profile. fixed uses the supplied value, ranged allows ranging between lb and ub, while create (must specify node_to) and destroy (must specify node_from) handle arbitrary energy flows that are bounded from below by 0. Use fixed if you want to fix the value of the Profile to a specific value, e.g., a given energy demand. Use create to \"import\" energy into the model, e.g., from a not explicitly modelled gas market, indcucing a certain cost for buying that energy. Use destroy to \"export\" energy from the model, e.g., to handle CO2 going into the atmosphere (which may be taxed, etc., by the cost of this Profile). Use ranged if you need more fine grained control over the value of the Profile, than what create and destroy allow (e.g., a grid limited energy supplier).\nlb no numeric power -infty The lower bound of the range of this Profile (must be used together with mode: ranged).\nub no numeric power +infty The upper bound of the range of this Profile (must be used together with mode: ranged).\ncost no numeric monetary per energy 0 Cost per unit of energy that this Profile injects or withdraws from a Node. Refer to the basic examples to see how this can be combined with mode for different use cases.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: aux_value\nnothing\n\nExpressions\n\ndetails: value\nnothing\n\nConstraints\n\ndetails: value_bounds\nnothing\n\nObjectives\n\ndetails: cost\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#IESopt.Unit-pages-manual___reference-api","page":"API","title":"IESopt.Unit","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\nconversion yes string - - The conversion expression describing how this Unit transforms energy. Specified in the form of \"alpha cdot carrier_1 + beta cdot carrier_2 -> gamma cdot carrier_3 + delta cdot carrier_4\". Coefficients allow simple numerical calculations, but are not allowed to include spaces (so e.g. (1.0/9.0) is valid). Coefficients are allowed to be NumericalInputs, resulting in column@data_file being a valid coefficient (this can be used e.g. for time-varying COPs of heatpumps).\ncapacity yes value dir:carrier - - Maximum capacity of this Unit, to be given in the format X in/out:carrier where X is the amount, in or out (followed by :) specifies whether the limit is to be placed on the in- our output of this Unit, and carrier specifies the respective Carrier. Example: 100 in:electricity (to limit the \"input rating\").\noutputs yes dict - - Dictionary specifying the output \"ports\" of this Unit. Refer to the basic examples for the general syntax.\ninputs no dict - - Dictionary specifying the input \"ports\" of this Unit. If not specified (= no explicit input), the conversion has to follow the form of conversion: ~ -> ..., indicating an \"open\" input. This may, e.g., be used for renewable energy sources, where the primary energy input (e.g., solar) is not explicitly modeled.\navailability no numeric power +infty Time series (or fixed value) that limits the available capacity. If, e.g., capacity: 100 out:electricity and availability: 70, the available capacity will only be 70 electricity. Can be used to model non-availability of power plants, e.g., due to maintenance. For time-varying availability of intermittent generators (e.g., wind), it's recommended (most of the time) to use availability_factor instead.\navailability_factor no in 0 1 - 1 Similar to availability, but given as factor of capacity instead. If, e.g., capacity: 100 out:electricity and availability_factor: 0.7, the available capacity will only be 70 electricity. This is especially useful for intermittent generators, where the availability is not a fixed value, but depends on the weather, and can be passed, e.g., by setting availability_factor: wind@input_data_file.\nadapt_min_to_availability no true, false - false If true, the minimal partial load will be influenced by the availability. Example: Consider a Unit with capacity: 100 out:electricity, a min_conversion of 0.4, and an availability_factor of 0.5. This entails having 50 electricity available, while the minimal partial load is 40 electricity. This results in the Unit at best operating only closely above the minimal partial load. Furthermore, an availability_factor below 0.4 would result in no feasible generation, besides shutting the Unit off. While this might be the intended mode of operation in many use cases, adapt_min_to_availability can change this: If set to true, this dynamically changes the minimal partial load. In the previous example, that means (100 * 0.5) * 0.4 = 20 electricity (the 50% minimum load are now based on the available 40), changing the overall behaviour (including efficiencies) as well as leading to feasible generations even when the availability_factor is below 0.4.\nmarginal_cost no value per dir:carrier monetary per energy 0 Marginal cost of the consumption/generation of one unit of energy of the specified carrier. Has to be given in the format value per dir:carrier, e.g. 3.5 per out:electricity for a marginal cost of 3.5 monetary units per unit of electricity generated.\nenable_ramp_up no true, false - false Enables calculation of upward ramps. Ramping is based on the carrier specified in capacity.\nenable_ramp_down no true, false - false Enables calculation of downward ramps. Ramping is based on the carrier specified in capacity.\nramp_up_cost no numeric monetary per power 0 Sets the cost of ramping up (increasing in-/output) by 1 unit of the capacity carrier.\nramp_down_cost no numeric monetary per power 0 Sets the cost of ramping down (decreasing in-/output) by 1 unit of the capacity carrier.\nramp_up_limit no in 0 1 - 1 Limits the allowed ramping up based on this factor of the total capacity. If capacity: 100 in:electricity with ramp_up_limit: 0.2, this limits the total increase of usage of electricity (on the input) to 20 units (power) per hour. For example, starting at an input of 35, after one hour the input has to be lesser than or equal to 55. If a Snapshot's duration is set to, e.g., two hours, this would allow a total increase of 40 units.\nramp_down_limit no in 0 1 - 1 Limits the allowed ramping down based on this factor of the total capacity. See ramp_up_limit.\nmin_on_time no numeric hours 0 Minimum on-time of the Unit. If set, the Unit has to be on for at least this amount of time, after turning on. It is highly recommended to only use this with unit_commitment: binary, unless you know why it's fine to use with another mode.\nmin_off_time no numeric hours 0 Minimum off-time of the Unit. If set, the Unit has to be off for at least this amount of time, after turning off. It is highly recommended to only use this with unit_commitment: binary, unless you know why it's fine to use with another mode.\non_time_before no numeric hours 0 Time that this Unit has already been running before the optimization starts. Can be used in combination with min_on_time.\noff_time_before no numeric hours 0 Time that this Unit has already been off before the optimization starts. Can be used in combination with min_off_time.\nis_on_before no numeric - 1 Number of Units that should be considered to have been running before the optimization starts. Can be used in combination with on_time_before, especially for unit_count greater than 1.\nunit_commitment no off, linear, binary, integer - off Controls how the unit commitment of this Unit is handled. linear results in the ability to startup parts of the unit (so 0.314159 is a feasible amount of \"turned on unit\"), while binary restricts the Unit to either be on (converting the conversion_at_min + possible additional conversion above that minimum) or off (converting nothing); integer is needed to consider binary unit commitment for Units with more than 1 \"grouped unit\" (see unit_count).\nunit_count no numeric - 1 Number of units aggregated in this Unit. Besides interacting with the mode of unit_commitment, this mainly is responsible for scaling the output (e.g. grouping 47 of the same wind turbine, ...).\nmin_conversion no in 0 1 - - If unit_commitment is not set to off, this specifies the percentage that is considered to be the minimal feasible partial load this Unit can operate at. Operating below that setpoint is not allowed, at that point the conversion_at_min coefficients are used, and above that they are scaled to result in conversion when running at full capacity.\nconversion_at_min no string - - The conversion expression while running on the minimal partial load. Only applicable if unit_commitment is not off and min_conversion is explicitly set. Follows the same form as conversion.\nstartup_cost no numeric monetary per start 0 Costs per startup (also applicable if startups are not binary or integer). This is necessary to allow conversion_at_min to have (at least partially) the effect that one expects, if unit_commitment: linear.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: conversion\nnothing\n\ndetails: ison\nnothing\n\ndetails: ramp\nnothing\n\ndetails: startup\nnothing\n\nExpressions\n\nConstraints\n\ndetails: conversion_bounds\nnothing\n\ndetails: ison\nnothing\n\ndetails: min_onoff_time\nnothing\n\ndetails: ramp\nnothing\n\ndetails: ramp_limit\nnothing\n\ndetails: startup\nnothing\n\nObjectives\n\ndetails: marginal_cost\nnothing\n\ndetails: ramp_cost\nnothing\n\ndetails: startup_cost\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/api/#Functions","page":"API","title":"Functions","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"run\ngenerate!\noptimize!","category":"page"},{"location":"pages/manual___reference/api/#IESopt.run","page":"API","title":"IESopt.run","text":"run(filename::String; kwargs...)\n\nBuild, optimize, and return a model.\n\nArguments\n\nfilename::String: The path to the top-level configuration file.\n\nKeyword Arguments\n\nKeyword arguments are passed to the normpath(__dir, ! function.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.generate!","page":"API","title":"IESopt.generate!","text":"generate!(filename::String; @nospecialize(kwargs...))\n\nGenerate an IESopt model based on the top-level config in filename.\n\nArguments\n\nfilename::String: The name of the file to load.\n\nKeyword Arguments\n\nTo be documented.\n\nReturns\n\nmodel::JuMP.Model: The generated IESopt model.\n\n\n\n\n\ngenerate!(model::JuMP.Model, filename::String; kwargs...)\n\nGenerates an IESopt model from a given file and attaches an optimizer if necessary.\n\nArguments\n\nmodel::JuMP.Model: The JuMP model to be used.\nfilename::String: The path to the file containing the model definition.\n\nKeyword Arguments\n\nTo be documented.\n\nReturns\n\nmodel::JuMP.Model: The generated IESopt model.\n\nNotes\n\nThe function validates the file before parsing and building the model.\nIf the model is not in DIRECT mode and has no optimizer attached, an optimizer is attached.\nThe function logs the model generation process and handles any exceptions that occur during generation.\nIf an error occurs, detailed debug information and the stack trace are logged.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.optimize!","page":"API","title":"IESopt.optimize!","text":"optimize!(model::JuMP.Model; kwargs...)\n\nOptimize the given IESopt model with optional keyword arguments.\n\nArguments\n\nmodel::JuMP.Model: The IESopt model to be optimized.\nkwargs...: Additional keyword arguments to be passed to the JuMP.optimize! function.\n\nDescription\n\nThis function performs the following steps:\n\nIf there are constraint safety penalties, it relaxes the constraints based on these penalties.\nSets the verbosity of the solver output based on the model's configuration.\nLogs the solver output to a file if logging is enabled and supported by the solver.\nCalls JuMP.optimize! to solve the model.\nChecks the result count and termination status to log the optimization outcome.\nAnalyzes the constraint safety results if there were any constraint safety penalties.\nExtracts and saves the results if the model is solved and feasible.\nProfiles the results after optimization.\n\nLogging\n\nLogs messages about the relaxation of constraints, solver output, and optimization status.\nLogs warnings if the safety constraint feature is triggered or if unexpected result counts are encountered.\nLogs errors if the solver log file setup fails, if no results are returned, or if extracting results is not possible.\n\nReturns\n\nnothing: This function does not return any value.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"get_component","category":"page"},{"location":"pages/manual___reference/api/#IESopt.get_component","page":"API","title":"IESopt.get_component","text":"function get_component(model::JuMP.Model, component_name::AbstractString)\n\nGet the component component_name from model.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"compute_IIS","category":"page"},{"location":"pages/manual___reference/api/#IESopt.compute_IIS","page":"API","title":"IESopt.compute_IIS","text":"function compute_IIS(model::JuMP.Model; filename::String = \"\")\n\nCompute the IIS and print it. If filename is specified it will instead write all constraints to the given file. This will fail if the solver does not support IIS computation.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"overview\npack\nunpack","category":"page"},{"location":"pages/manual___reference/api/#IESopt.overview","page":"API","title":"IESopt.overview","text":"overview(file::String)\n\nExtracts the most important information from an IESopt model file, and returns it as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.pack","page":"API","title":"IESopt.pack","text":"pack(file::String; out::String=\"\", method=:store)\n\nPacks the IESopt model specified by the top-level config file file into single file.\n\nThe out argument specifies the output file name. If not specified, a temporary file is created. Returns the output file name. The method argument specifies the compression method to use. The default is :store, which means no compression is used. The other option is :deflate, which uses the DEFLATE compression method. The default (:auto) applies :store to all files below 1 MB, :deflate otherwise.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#IESopt.unpack","page":"API","title":"IESopt.unpack","text":"unpack(file::String; out::String=\"\", force_overwrite::Bool=false)\n\nUnpacks the IESopt model specified by file.\n\nThe out argument specifies the output directory. If not specified, a temporary directory is created. Returns the path to the top-level config file. The force_overwrite argument specifies whether to overwrite existing files.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual___reference/api/#Python","page":"API","title":"Python","text":"","category":"section"},{"location":"pages/manual___reference/api/","page":"API","title":"API","text":"To be added.","category":"page"},{"location":"#IESopt.jl","page":"Home","title":"IESopt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integrated Energy System Optimization framework written in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IESopt.jl is the core of the IESopt framework, developed at AIT Austrian Institute of Technology GmbH. It is written in Julia, and uses JuMP package to construct the underlying mathematical optimization models, and to interface with various solvers. The model is designed to be modular, and allows for easy extension and customization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out the following GitHub repositories for more information:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IESopt.jl, the core model (a Julia package).\niesopt, the Python interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"danger: Merging documentations\nWe are currently merging this documentation into the (now) central one, over at working iesopt. Besides migrating everything, this requires some clean-up of (potentially) confindential left-overs (e.g., from projects), so the documentation needs to be checked page-by-page. If you are trying to get started before we manage to fix everything, get in touch with us directly - we'll help you set up everything you need.","category":"page"},{"location":"pages/dev_docs/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following sections provide rough guidelines on how to work with IESopt, and mostly IESopt.jl, improving the documentation, testing, and implementing new features.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"info: Helping out\nLooking for things to contribute, with a low entry barrier (besides any open issue)? Check for To be added (especially in the documentation), or TODO (especially in the code).","category":"page"},{"location":"pages/dev_docs/#Getting-started","page":"Developer Documentation","title":"Getting started","text":"","category":"section"},{"location":"pages/dev_docs/#General","page":"Developer Documentation","title":"General","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Install Julia.\nInstall VSCode, and some extensions (this step is optional, but highly recommended).\nClone/fork the repository.\nHappy coding (... see below)!","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"If you are new to Julia, or not entirely sure how everything works - let's talk. We are happy to help you get started, and to guide you through the process. Stuff like Revise.jl can be a huge help, and we can show you how to use it. Further, if you are coming from, e.g., a standard Python background, the advantages of a dynamic REPL-driven development may be new to you.","category":"page"},{"location":"pages/dev_docs/#Tips-and-tricks","page":"Developer Documentation","title":"Tips and tricks","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Check out Modern Julia Workflows.\nCheck out the Julia Discourse.\nRead up details on Revise usage.","category":"page"},{"location":"pages/dev_docs/#Architecture","page":"Developer Documentation","title":"Architecture","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"See ARCHITECTURE.md for more information.","category":"page"},{"location":"pages/dev_docs/#Coding-conventions","page":"Developer Documentation","title":"Coding conventions","text":"","category":"section"},{"location":"pages/dev_docs/#Branches","page":"Developer Documentation","title":"Branches","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We mainly use a \"feature branch workflow\", similar to \"trunk based development\". We strive to keep the main branch as clean as possible (docs and tests should build and pass), and work on a separate development (trunk) branch. For larger changes, consider starting new feature branches. Where possible we use PRs (or merge requests) to get changes into the main branch, while doing a (light) code review for each other.","category":"page"},{"location":"pages/dev_docs/#Naming-conventions","page":"Developer Documentation","title":"Naming conventions","text":"","category":"section"},{"location":"pages/dev_docs/#Julia","page":"Developer Documentation","title":"Julia","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We make use of the following naming conventions, which slightly differ from the Julia naming conventions, but are similar to other large projects out there:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Types and similar items use CamelCase, e.g., MyType.\nFunctions and variables use snake_case, e.g., my_function(...).\nFunctions that modify their arguments should end with an exclamation mark, e.g., optimize!(...).\nFunctions and variables should actually make use of underscores, whenever reasonable (and not only when absolutely necessary), e.g., set_to_zero!(...) (not settozero!(...) like the Julia naming conventions may suggest).\nConstants are written in UPPERCASE, e.g., MY_CONSTANT.","category":"page"},{"location":"pages/dev_docs/#Python","page":"Developer Documentation","title":"Python","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"To be added (black with --line-length 88, ruff, standard naming conventions, ...).","category":"page"},{"location":"pages/dev_docs/#Conventional-commits","page":"Developer Documentation","title":"Conventional commits","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Refer to the Conventional Commits specification for a detailed explanation. In short, we use the following format:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"feat: implemented new feature X\nfix: fixed the bug X\nrefactor: refactored the code X\ndocs: updated the documentation X\ntest: added a new test for X\nchore: updated the dependencies X","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"As indicated we use docs, but test (and not tests), which can be remembered by looking at the folder names: docs/ and test/.","category":"page"},{"location":"pages/dev_docs/#Version-numbers","page":"Developer Documentation","title":"Version numbers","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Documenter.jl (as of May, 22nd, 2024) aggressively states: \"Documenter, like any good Julia package, follows semantic versioning (SemVer).\"","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Unfortunately, semantic versioning may not be as well suited as one might think for a package like IESopt.jl. Some reasons are:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"While the (Julia) API has been stable for a long time (in a sense of: backwards-compatible), we consider the YAML configuration syntax as main part of IESopt's \"API\". This syntax has changed multiple times, and will likely change in the future. Maintaining full backwards compatibility for this is not feasible all the time. This induces a need for a major version bump, even though the Julia API has not changed.\nA mere bug fix, even a small one, in IESopt.jl may very likely induce changed results of any model run. A user could see vastly different results between v1.3.10 and v1.3.11, even though the changes are minimal. This involves not taking patch updates lightly, which is not the case in many other packages.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"However, as indicated, the use of semantic versioning is still \"expected\" by large parts of the Julia community, and not doing so may make it harder for some users, and/or some interactions with other packages. So...","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"IESopt.jl makes use of semantic versioning!\nYou are advised to consider the above points when deciding on version bumps.\nAdvise users and make sure you properly document changes.\nExpect rising major version numbers.","category":"page"},{"location":"pages/dev_docs/#Working-with-VSCode","page":"Developer Documentation","title":"Working with VSCode","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following set of extensions may be helpful, either for development or documentation purposes:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Julia\nLive Preview\nMarkdown Julia\nMarkdown Preview GitHub Styling\nmarkdownlint\nRainbow CSV","category":"page"},{"location":"pages/dev_docs/#Improving-the-documentation","page":"Developer Documentation","title":"Improving the documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"# TODO: refactor to new syntax: `julia --project=. -e 'include(\"docs/liveserver.jl\")'`","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Docstrings of public entries of IESopt.jl are taken from the code, see src/.... Besides that, the documentation is contained in the docs/src/... folder, and built based on docs/make.jl, using Documenter.jl.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"info: Ditaxis\nConsider checking out the excellent \"project\" Ditaxis, by Daniele Procida. We try to adhere to the principles outlined there, and you may find them useful as well. For a quick intro, you may consider starting here: The difference between a tutorial and how-to guide.","category":"page"},{"location":"pages/dev_docs/#Setup","page":"Developer Documentation","title":"Setup","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Make sure that you","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"have a working installation of Julia (otherwise go to julialang.org and install it; we recommend sticking to Juliaup if asked), and\nhave a terminal of your choice launched at IESopt.jl/.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Then, run the following command once to set up the environment used for the documentation:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"julia --project=docs -e 'import Pkg; Pkg.instantiate()'","category":"page"},{"location":"pages/dev_docs/#Building-the-documentation","page":"Developer Documentation","title":"Building the documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Launch an interactive web server that shows you the documentation while you are working on it:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"julia --project=docs -e 'using LiveServer; servedocs(; launch_browser=true)'","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Note: While the above is your best choice in 95% of all cases, you can also manually build the documentation usingjulia --project=docs docs/make.jlwhich may be useful if you modify source files (which LiveServer.jl currently does not track in a convenient way). Note however that this will not automatically reload the documentation in your browser (but may in VSCode if you right-click the index.html file and select Preview, using the Live Preview extension), and may fail to properly account for image/... paths.","category":"page"},{"location":"pages/dev_docs/#Code-formatting","page":"Developer Documentation","title":"Code formatting","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We provide a custom .JuliaFormatter.toml file that should be used to format the code. The easiest way to use it is to:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Add JuliaFormatter to your Julia base environment by running ] add JuliaFormatter in the package mode of your Julia REPL (without an active IESopt environment).\nRun using JuliaFormatter in the Julia REPL (this now works even if you activated the IESopt environment).\nRun format(\".\") in the Julia REPL to format all files in your current directory. This takes a bit of compile time, but after the first run, it should be fairly fast.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Make sure you checked the formatting, before finalizing your changes or opening a PR. If you forgot to include formatting in your actual commits (we all do...), and cannot reasonably amend them, add all formatting changes at the end in a single commit with the message:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"git commit -m \"chore: formatting\"","category":"page"},{"location":"pages/dev_docs/#Testing","page":"Developer Documentation","title":"Testing","text":"","category":"section"},{"location":"pages/dev_docs/#Running-tests-locally","page":"Developer Documentation","title":"Running tests locally","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Launch a new Julia REPL (hit Alt+J and then Alt+O in VSCode), enter Package mode (by pressing ] in your REPL, now showing (IESopt) pkg>), and then execute all tests by running:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"(IESopt) pkg> test","category":"page"},{"location":"pages/manual___reference/core_components/#Model-formulation","page":"Model formulation","title":"Model formulation","text":"","category":"section"},{"location":"pages/manual___reference/core_components/","page":"Model formulation","title":"Model formulation","text":"This page collects all information about the core components of IESopt, their properties (and default values), their internal mathematical formulations, and some examples of how to use them. See the API for a complete list of all available functions and types.","category":"page"},{"location":"pages/manual___reference/core_components/","page":"Model formulation","title":"Model formulation","text":"CurrentModule       = IESopt\nCollapsedDocStrings = true","category":"page"},{"location":"pages/manual___reference/core_components/","page":"Model formulation","title":"Model formulation","text":"Connection\nDecision\nNode\nProfile\nUnit","category":"page"},{"location":"pages/manual___reference/core_components/#IESopt.Connection","page":"Model formulation","title":"IESopt.Connection","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\nnode_from yes string - - This Connection models a flow from node_from to node_to (both are Nodes).\nnode_to yes string - - This Connection models a flow from node_from to node_to (both are Nodes).\ncarrier no string - - Carrier of this Connection. If not given, automatically picks the carrier of the Nodes it connects. This parameter is not necessary, and only exists to allow for a more explicit definition.\ncapacity no numeric, col@file, decision:value power +infty The symmetric bound on this Connection's flow. Results in lb = -capacity and ub = capacity. Must not be specified if lb, ub, or both are explicitly stated.\nlb no numeric, col@file, decision:value power -infty Lower bound of this Connection's flow.\nub no numeric, col@file, decision:value power +infty Upper bound of this Connection's flow.\ncost no numeric monetary (per energy) - Cost of every unit of energy flow over this connection that is added to the model's objective function. Keep in mind that negative flows will induce negative costs, which can be used to model revenues. Further, a bidirectional Connection (if lb < 0, which is the default, or if capacity is used) with a positive cost will lead to negative costs for the reverse flow. If you do not want this, split the Connection into two separate ones, each being unidirectional (with lb: 0). Remember, that these can share the same \"capacity\" (which is then set asub), even when using decision:value or col@file as value.\nloss no in 0 1 - 0 Fractional loss when transferring energy. This loss occurs \"at the destination\", which means that for a loss of 5%, set as loss: 0.05, and considering a Snapshot where the Connection has a flow value of 100, it will \"extract\" 100 from node_from and \"inject\" 95 into node_to. Since the flow variable is given as power, this would, e.g., translate to consuming 200 units of energy at node_from and injecting 190 units at node_to, if the Snapshot duration is 2 hours.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: flow\nnothing\n\nExpressions\n\ndetails: pf_flow\nnothing\n\nConstraints\n\ndetails: flow_bounds\nnothing\n\nObjectives\n\ndetails: cost\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Decision","page":"Model formulation","title":"IESopt.Decision","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\nlb no numeric - 0 Minimum size of the decision value (considered for each \"unit\" if count allows multiple \"units\").\nub no numeric - +infty Maximum size of the decision value (considered for each \"unit\" if count allows multiple \"units\").\ncost no numeric monetary (per value) 0 Cost that the decision value induces, given as cost cdot value.\nfixed_value no numeric - - If mode: fixed, this value is used as the fixed value of the decision. This can be useful if this Decision was used in a previous optimization and its value should be fixed to that value in the next optimization (applying it where ever it is used, instead of needing to find all usages). Furthermore, this allows extracting the dual value of the constraint that fixes the value, assisting in approaches like Benders decomposition. Note that this does not change the induced cost in any way.\nfixed_cost no - monetary - This setting activates a \"fixed cost\" component for this decision variable, which requires that the model's problem type allows for binary variables (e.g., MILP). This can be used to model fixed costs that are only incurred if the decision variable is active (e.g., a fixed cost for an investment that is only incurred if the investment is made). If the decision is 0, no fixed costs have to be paid; however, if the decision is greater than 0, the fixed cost is incurred. Note that after deciding to activate the decision, the overall value is still determined in the usual (continuous) way, incuring the (variable) cost as well. More complex cost functions can be modelled by switching to mode sos1 or sos2 and using the sos parameter.\nmode no linear, binary, integer, sos1, sos2, fixed - linear Type of the decision variable that is constructed. linear results in a continuous decision, integer results in a integer variable, binary constrains it to be either 0 or 1. sos1 and sos2 can be used to activate SOS1 or SOS2 mode (used for piecewise linear costs). See fixed_value if setting this to fixed.\nsos no list - - TODO (meanwhile, refer to the SOS or PiecewiseLinearCost example).\nbuild_priority no numeric - 1000 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: fixed\nnothing\n\ndetails: sos\nnothing\n\ndetails: value\nnothing\n\nExpressions\n\nConstraints\n\ndetails: fixed\nnothing\n\ndetails: sos1\nnothing\n\ndetails: sos2\nnothing\n\ndetails: sos_value\nnothing\n\nObjectives\n\ndetails: fixed\nnothing\n\ndetails: sos\nnothing\n\ndetails: value\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Node","page":"Model formulation","title":"IESopt.Node","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\ncarrier yes string - - Carrier of this Node. All connecting components need to respect that.\nhas_state no true, false - false If true, the Node is considered to have an internal state (\"stateful Node\"). This allows it to act as energy storage. Connect Connections or Units to it, acting as charger/discharger.\nstate_lb no numeric, col@file, decision:value energy -infty Lower bound of the internal state, requires has_state = true.\nstate_ub no numeric, col@file, decision:value energy +infty Upper bound of the internal state, requires has_state = true.\nstate_cyclic no eq, geq, or disabled - eq Controls how the state considers the boundary between last and first Snapshot. disabled disables cyclic behaviour of the state (see also state_initial), eq leads to the state at the end of the year being the initial state at the beginning of the year, while geq does the same while allowing the end-of-year state to be higher (= \"allowing to destroy energy at the end of the year\").\nstate_initial no numeric energy - Sets the initial state. Must be used in combination with state_cyclic = disabled.\nstate_final no numeric energy - Sets the final state. Must be used in combination with state_cyclic = disabled.\nstate_percentage_loss no in 0 1 - 0 Per Snapshot percentage loss of state (losing 1% should be set as 0.01).\nnodal_balance no enforce, destroy, or create - enforce Can only be used for has_state = false. enforce forces total injections to always be zero (similar to Kirchhoff's current law), create allows \"supply < demand\", destroy allows \"supply > demand\", at this Node.\nsum_window_size no integer - - TODO.\nsum_window_step no integer - 1 TODO.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: pf_theta\nnothing\n\ndetails: state\nnothing\n\nExpressions\n\ndetails: injection\nnothing\n\nConstraints\n\ndetails: last_state\nnothing\n\ndetails: nodalbalance\nnothing\n\ndetails: state_bounds\nnothing\n\nObjectives\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Profile","page":"Model formulation","title":"IESopt.Profile","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\ncarrier yes string - - Carrier of this Profile. Must match the Carrier of the Node that this connects to.\nvalue no numeric, col@file power - The concrete value of this Profile - either static or as time series. Only applicable if mode: fixed.\nnode_from no string - - Name of the Node that this Profile draws energy from. Exactly one of node_from and node_to must be set.\nnode_to no string - - Name of the Node that this Profile feeds energy to. Exactly one of node_from and node_to must be set.\nmode no - - fixed The mode of operation of this Profile. fixed uses the supplied value, ranged allows ranging between lb and ub, while create (must specify node_to) and destroy (must specify node_from) handle arbitrary energy flows that are bounded from below by 0. Use fixed if you want to fix the value of the Profile to a specific value, e.g., a given energy demand. Use create to \"import\" energy into the model, e.g., from a not explicitly modelled gas market, indcucing a certain cost for buying that energy. Use destroy to \"export\" energy from the model, e.g., to handle CO2 going into the atmosphere (which may be taxed, etc., by the cost of this Profile). Use ranged if you need more fine grained control over the value of the Profile, than what create and destroy allow (e.g., a grid limited energy supplier).\nlb no numeric power -infty The lower bound of the range of this Profile (must be used together with mode: ranged).\nub no numeric power +infty The upper bound of the range of this Profile (must be used together with mode: ranged).\ncost no numeric monetary per energy 0 Cost per unit of energy that this Profile injects or withdraws from a Node. Refer to the basic examples to see how this can be combined with mode for different use cases.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: aux_value\nnothing\n\nExpressions\n\ndetails: value\nnothing\n\nConstraints\n\ndetails: value_bounds\nnothing\n\nObjectives\n\ndetails: cost\nnothing\n\n\n\n\n\n","category":"type"},{"location":"pages/manual___reference/core_components/#IESopt.Unit","page":"Model formulation","title":"IESopt.Unit","text":"nothing\n\nParameters\n\nName Mandatory Values Unit Default Description\nconversion yes string - - The conversion expression describing how this Unit transforms energy. Specified in the form of \"alpha cdot carrier_1 + beta cdot carrier_2 -> gamma cdot carrier_3 + delta cdot carrier_4\". Coefficients allow simple numerical calculations, but are not allowed to include spaces (so e.g. (1.0/9.0) is valid). Coefficients are allowed to be NumericalInputs, resulting in column@data_file being a valid coefficient (this can be used e.g. for time-varying COPs of heatpumps).\ncapacity yes value dir:carrier - - Maximum capacity of this Unit, to be given in the format X in/out:carrier where X is the amount, in or out (followed by :) specifies whether the limit is to be placed on the in- our output of this Unit, and carrier specifies the respective Carrier. Example: 100 in:electricity (to limit the \"input rating\").\noutputs yes dict - - Dictionary specifying the output \"ports\" of this Unit. Refer to the basic examples for the general syntax.\ninputs no dict - - Dictionary specifying the input \"ports\" of this Unit. If not specified (= no explicit input), the conversion has to follow the form of conversion: ~ -> ..., indicating an \"open\" input. This may, e.g., be used for renewable energy sources, where the primary energy input (e.g., solar) is not explicitly modeled.\navailability no numeric power +infty Time series (or fixed value) that limits the available capacity. If, e.g., capacity: 100 out:electricity and availability: 70, the available capacity will only be 70 electricity. Can be used to model non-availability of power plants, e.g., due to maintenance. For time-varying availability of intermittent generators (e.g., wind), it's recommended (most of the time) to use availability_factor instead.\navailability_factor no in 0 1 - 1 Similar to availability, but given as factor of capacity instead. If, e.g., capacity: 100 out:electricity and availability_factor: 0.7, the available capacity will only be 70 electricity. This is especially useful for intermittent generators, where the availability is not a fixed value, but depends on the weather, and can be passed, e.g., by setting availability_factor: wind@input_data_file.\nadapt_min_to_availability no true, false - false If true, the minimal partial load will be influenced by the availability. Example: Consider a Unit with capacity: 100 out:electricity, a min_conversion of 0.4, and an availability_factor of 0.5. This entails having 50 electricity available, while the minimal partial load is 40 electricity. This results in the Unit at best operating only closely above the minimal partial load. Furthermore, an availability_factor below 0.4 would result in no feasible generation, besides shutting the Unit off. While this might be the intended mode of operation in many use cases, adapt_min_to_availability can change this: If set to true, this dynamically changes the minimal partial load. In the previous example, that means (100 * 0.5) * 0.4 = 20 electricity (the 50% minimum load are now based on the available 40), changing the overall behaviour (including efficiencies) as well as leading to feasible generations even when the availability_factor is below 0.4.\nmarginal_cost no value per dir:carrier monetary per energy 0 Marginal cost of the consumption/generation of one unit of energy of the specified carrier. Has to be given in the format value per dir:carrier, e.g. 3.5 per out:electricity for a marginal cost of 3.5 monetary units per unit of electricity generated.\nenable_ramp_up no true, false - false Enables calculation of upward ramps. Ramping is based on the carrier specified in capacity.\nenable_ramp_down no true, false - false Enables calculation of downward ramps. Ramping is based on the carrier specified in capacity.\nramp_up_cost no numeric monetary per power 0 Sets the cost of ramping up (increasing in-/output) by 1 unit of the capacity carrier.\nramp_down_cost no numeric monetary per power 0 Sets the cost of ramping down (decreasing in-/output) by 1 unit of the capacity carrier.\nramp_up_limit no in 0 1 - 1 Limits the allowed ramping up based on this factor of the total capacity. If capacity: 100 in:electricity with ramp_up_limit: 0.2, this limits the total increase of usage of electricity (on the input) to 20 units (power) per hour. For example, starting at an input of 35, after one hour the input has to be lesser than or equal to 55. If a Snapshot's duration is set to, e.g., two hours, this would allow a total increase of 40 units.\nramp_down_limit no in 0 1 - 1 Limits the allowed ramping down based on this factor of the total capacity. See ramp_up_limit.\nmin_on_time no numeric hours 0 Minimum on-time of the Unit. If set, the Unit has to be on for at least this amount of time, after turning on. It is highly recommended to only use this with unit_commitment: binary, unless you know why it's fine to use with another mode.\nmin_off_time no numeric hours 0 Minimum off-time of the Unit. If set, the Unit has to be off for at least this amount of time, after turning off. It is highly recommended to only use this with unit_commitment: binary, unless you know why it's fine to use with another mode.\non_time_before no numeric hours 0 Time that this Unit has already been running before the optimization starts. Can be used in combination with min_on_time.\noff_time_before no numeric hours 0 Time that this Unit has already been off before the optimization starts. Can be used in combination with min_off_time.\nis_on_before no numeric - 1 Number of Units that should be considered to have been running before the optimization starts. Can be used in combination with on_time_before, especially for unit_count greater than 1.\nunit_commitment no off, linear, binary, integer - off Controls how the unit commitment of this Unit is handled. linear results in the ability to startup parts of the unit (so 0.314159 is a feasible amount of \"turned on unit\"), while binary restricts the Unit to either be on (converting the conversion_at_min + possible additional conversion above that minimum) or off (converting nothing); integer is needed to consider binary unit commitment for Units with more than 1 \"grouped unit\" (see unit_count).\nunit_count no numeric - 1 Number of units aggregated in this Unit. Besides interacting with the mode of unit_commitment, this mainly is responsible for scaling the output (e.g. grouping 47 of the same wind turbine, ...).\nmin_conversion no in 0 1 - - If unit_commitment is not set to off, this specifies the percentage that is considered to be the minimal feasible partial load this Unit can operate at. Operating below that setpoint is not allowed, at that point the conversion_at_min coefficients are used, and above that they are scaled to result in conversion when running at full capacity.\nconversion_at_min no string - - The conversion expression while running on the minimal partial load. Only applicable if unit_commitment is not off and min_conversion is explicitly set. Follows the same form as conversion.\nstartup_cost no numeric monetary per start 0 Costs per startup (also applicable if startups are not binary or integer). This is necessary to allow conversion_at_min to have (at least partially) the effect that one expects, if unit_commitment: linear.\nbuild_priority no numeric - 0 Priority for the build order of components. Components with higher build_priority are built before. This can be useful for addons, that connect multiple components and rely on specific components being initialized before others.\n\nDetailed Model Reference\n\nVariables\n\ndetails: conversion\nnothing\n\ndetails: ison\nnothing\n\ndetails: ramp\nnothing\n\ndetails: startup\nnothing\n\nExpressions\n\nConstraints\n\ndetails: conversion_bounds\nnothing\n\ndetails: ison\nnothing\n\ndetails: min_onoff_time\nnothing\n\ndetails: ramp\nnothing\n\ndetails: ramp_limit\nnothing\n\ndetails: startup\nnothing\n\nObjectives\n\ndetails: marginal_cost\nnothing\n\ndetails: ramp_cost\nnothing\n\ndetails: startup_cost\nnothing\n\n\n\n\n\n","category":"type"}]
}
