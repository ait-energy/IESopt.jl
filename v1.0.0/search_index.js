var documenterSearchIndex = {"docs":
[{"location":"pages/tutorials/next_steps/#Next-steps","page":"Next steps","title":"Next steps","text":"","category":"section"},{"location":"pages/tutorials/next_steps/","page":"Next steps","title":"Next steps","text":"To be added.","category":"page"},{"location":"pages/user_guide/solvers/#Solvers","page":"Solvers","title":"Solvers","text":"","category":"section"},{"location":"pages/user_guide/solvers/#Recommended-Configurations","page":"Solvers","title":"Recommended Configurations","text":"","category":"section"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"The following configurations can be seen as helpful starting point on how to configure different solvers for large-scale models. They are largely based on other model's defaults (see e.g. PyPSA).","category":"page"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"More informations can be found at:","category":"page"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"HiGHS:\nhttps://ergo-code.github.io/HiGHS/stable/options/definitions/\nGurobi:\nhttps://www.gurobi.com/wp-content/uploads/2022-10-ParisAdvancedAlgorithms.pdf\nhttps://www.gurobi.com/documentation/current/refman/parameters.html\nCPLEX:\nhttps://www.ibm.com/docs/en/icos/22.1.1?topic=cplex-list-parameters","category":"page"},{"location":"pages/user_guide/solvers/#HiGHS","page":"Solvers","title":"HiGHS","text":"","category":"section"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"solver:\n  name: highs\n  attributes:\n    threads: 4\n    solver: \"ipm\"\n    run_crossover: \"off\"\n    small_matrix_value: 1e-6\n    large_matrix_value: 1e9\n    primal_feasibility_tolerance: 1e-5\n    dual_feasibility_tolerance: 1e-5\n    ipm_optimality_tolerance: 1e-4\n    parallel: \"on\"\n    random_seed: 1234","category":"page"},{"location":"pages/user_guide/solvers/#Gurobi","page":"Solvers","title":"Gurobi","text":"","category":"section"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"solver:\n  name: gurobi\n  attributes:\n    Method: 2\n    Crossover: 0\n    BarConvTol: 1.e-6\n    Seed: 123\n    AggFill: 0\n    PreDual: 0\n    GURO_PAR_BARDENSETHRESH: 200\n    Threads: 8\n    Seed: 1234","category":"page"},{"location":"pages/user_guide/solvers/#Gurobi-(NumFocus)","page":"Solvers","title":"Gurobi (NumFocus)","text":"","category":"section"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"For models with \"challenging\" numerical properties, the following can be useful:","category":"page"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"solver:\n  name: gurobi\n  attributes:\n    NumericFocus: 3\n    Method: 2\n    Crossover: 0\n    BarHomogeneous: 1\n    BarConvTol: 1.e-5\n    FeasibilityTol: 1.e-4\n    OptimalityTol: 1.e-4\n    ObjScale: -0.5\n    Threads: 8\n    Seed: 1234","category":"page"},{"location":"pages/user_guide/solvers/#Gurobi-(fallback)","page":"Solvers","title":"Gurobi (fallback)","text":"","category":"section"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"solver:\n  name: gurobi\n  attributes:\n    Crossover: 0\n    Method: 2\n    BarHomogeneous: 1\n    BarConvTol: 1.e-5\n    FeasibilityTol: 1.e-5\n    OptimalityTol: 1.e-5\n    Threads: 8\n    Seed: 1234","category":"page"},{"location":"pages/user_guide/solvers/#CPLEX","page":"Solvers","title":"CPLEX","text":"","category":"section"},{"location":"pages/user_guide/solvers/","page":"Solvers","title":"Solvers","text":"solver:\n  name: cplex\n  attributes:\n    threads: 4\n    lpmethod: 4\n    solutiontype: 2\n    barrier_convergetol: 1.e-5\n    feasopt_tolerance: 1.e-6","category":"page"},{"location":"pages/manual/templates/#Template-Reference","page":"Template Reference","title":"Template Reference","text":"","category":"section"},{"location":"pages/manual/templates/","page":"Template Reference","title":"Template Reference","text":"To be added (explanation).","category":"page"},{"location":"pages/dev_docs/#Developer-Documentation","page":"Developer Documentation","title":"Developer Documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following sections provide rough guidelines on how to work with IESopt, and mostly IESopt.jl, improving the documentation, testing, and implementing new features.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"info: Helping out\nLooking for things to contribute, with a low entry barrier (besides any open issue)? Check for To be added (especially in the documentation), or TODO (especially in the code).","category":"page"},{"location":"pages/dev_docs/#Getting-started","page":"Developer Documentation","title":"Getting started","text":"","category":"section"},{"location":"pages/dev_docs/#General","page":"Developer Documentation","title":"General","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Install Julia.\nInstall VSCode, and some extensions (this step is optional, but highly recommended).\nClone/fork the repository.\nHappy coding (... see below)!","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"If you are new to Julia, or not entirely sure how everything works - let's talk. We are happy to help you get started, and to guide you through the process. Stuff like Revise.jl can be a huge help, and we can show you how to use it. Further, if you are coming from, e.g., a standard Python background, the advantages of a dynamic REPL-driven development may be new to you.","category":"page"},{"location":"pages/dev_docs/#Tips-and-tricks","page":"Developer Documentation","title":"Tips and tricks","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Check out Modern Julia Workflows.\nCheck out the Julia Discourse.\nRead up details on Revise usage.","category":"page"},{"location":"pages/dev_docs/#Architecture","page":"Developer Documentation","title":"Architecture","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"See ARCHITECTURE.md for more information.","category":"page"},{"location":"pages/dev_docs/#Coding-conventions","page":"Developer Documentation","title":"Coding conventions","text":"","category":"section"},{"location":"pages/dev_docs/#Branches","page":"Developer Documentation","title":"Branches","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We mainly use a \"feature branch workflow\", similar to \"trunk based development\". We strive to keep the main branch as clean as possible (docs and tests should build and pass), and work on a separate development (trunk) branch. For larger changes, consider starting new feature branches. Where possible we use PRs (or merge requests) to get changes into the main branch, while doing a (light) code review for each other.","category":"page"},{"location":"pages/dev_docs/#Naming-conventions","page":"Developer Documentation","title":"Naming conventions","text":"","category":"section"},{"location":"pages/dev_docs/#Julia","page":"Developer Documentation","title":"Julia","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We make use of the following naming conventions, which slightly differ from the Julia naming conventions, but are similar to other large projects out there:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Types and similar items use CamelCase, e.g., MyType.\nFunctions and variables use snake_case, e.g., my_function(...).\nFunctions that modify their arguments should end with an exclamation mark, e.g., optimize!(...).\nFunctions and variables should actually make use of underscores, whenever reasonable (and not only when absolutely necessary), e.g., set_to_zero!(...) (not settozero!(...) like the Julia naming conventions may suggest).\nConstants are written in UPPERCASE, e.g., MY_CONSTANT.","category":"page"},{"location":"pages/dev_docs/#Python","page":"Developer Documentation","title":"Python","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"To be added (black with --line-length 88, ruff, standard naming conventions, ...).","category":"page"},{"location":"pages/dev_docs/#Conventional-commits","page":"Developer Documentation","title":"Conventional commits","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Refer to the Conventional Commits specification for a detailed explanation. In short, we use the following format:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"feat: implemented new feature X\nfix: fixed the bug X\nrefactor: refactored the code X\ndocs: updated the documentation X\ntest: added a new test for X\nchore: updated the dependencies X","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"As indicated we use docs, but test (and not tests), which can be remembered by looking at the folder names: docs/ and test/.","category":"page"},{"location":"pages/dev_docs/#Version-numbers","page":"Developer Documentation","title":"Version numbers","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Documenter.jl (as of May, 22nd, 2024) aggressively states: \"Documenter, like any good Julia package, follows semantic versioning (SemVer).\"","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Unfortunately, semantic versioning may not be as well suited as one might think for a package like IESopt.jl. Some reasons are:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"While the (Julia) API has been stable for a long time (in a sense of: backwards-compatible), we consider the YAML configuration syntax as main part of IESopt's \"API\". This syntax has changed multiple times, and will likely change in the future. Maintaining full backwards compatibility for this is not feasible all the time. This induces a need for a major version bump, even though the Julia API has not changed.\nA mere bug fix, even a small one, in IESopt.jl may very likely induce changed results of any model run. A user could see vastly different results between v1.3.10 and v1.3.11, even though the changes are minimal. This envolves not taking patch updates lightly, which is not the case in many other packages.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"However, as indicated, the use of semantic versioning is still \"expected\" by large parts of the Julia community, and not doing so may make it harder for some users, and/or some interactions with other packages. So...","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"IESopt.jl makes use of semantic versioning!\nYou are advised to consider the above points when deciding on version bumps.\nAdvise users and make sure you properly document changes.\nExpect rising major version numbers.","category":"page"},{"location":"pages/dev_docs/#Working-with-VSCode","page":"Developer Documentation","title":"Working with VSCode","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"The following set of extensions may be helpful, either for development or documentation purposes:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Julia\nLive Preview\nMarkdown Julia\nMarkdown Preview GitHub Styling\nmarkdownlint\nRainbow CSV","category":"page"},{"location":"pages/dev_docs/#Improving-the-documentation","page":"Developer Documentation","title":"Improving the documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"# TODO: refactor to new syntax: `julia --project=. -e 'include(\"docs/liveserver.jl\")'`","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Docstrings of public entries of IESopt.jl are taken from the code, see src/.... Besides that, the documentation is contained in the docs/src/... folder, and built based on docs/make.jl, using Documenter.jl.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"info: Diátaxis\nConsider checking out the excellent \"project\" Diátaxis, by Daniele Procida. We try to adhere to the principles outlined there, and you may find them useful as well. For a quick intro, you may consider starting here: The difference between a tutorial and how-to guide.","category":"page"},{"location":"pages/dev_docs/#Setup","page":"Developer Documentation","title":"Setup","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Make sure that you","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"have a working installation of Julia (otherwise go to julialang.org and install it; we recommend sticking to Juliaup if asked), and\nhave a terminal of your choice launched at IESopt.jl/.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Then, run the following command once to set up the environment used for the documentation:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"julia --project=docs -e 'import Pkg; Pkg.instantiate()'","category":"page"},{"location":"pages/dev_docs/#Building-the-documentation","page":"Developer Documentation","title":"Building the documentation","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Launch an interactive web server that shows you the documentation while you are working on it:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"julia --project=docs -e 'using LiveServer; servedocs(; launch_browser=true)'","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Note: While the above is your best choice in 95% of all cases, you can also manually build the documentation usingjulia --project=docs docs/make.jlwhich may be useful if you modify source files (which LiveServer.jl currently does not track in a convenient way). Note however that this will not automatically reload the documentation in your browser (but may in VSCode if you right-click the index.html file and select Preview, using the Live Preview extension), and may fail to properly account for image/... paths.","category":"page"},{"location":"pages/dev_docs/#Code-formatting","page":"Developer Documentation","title":"Code formatting","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"We provide a custom .JuliaFormatter.toml file that should be used to format the code. The easiest way to use it is to:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Add JuliaFormatter to your Julia base environment by running ] add JuliaFormatter in the package mode of your Julia REPL (without an active IESopt environment).\nRun using JuliaFormatter in the Julia REPL (this now works even if you activated the IESopt environment).\nRun format(\".\") in the Julia REPL to format all files in your current directory. This takes a bit of compile time, but after the first run, it should be fairly fast.","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Make sure you checked the formatting, before finalizing your changes or opening a PR. If you forgot to include formatting in your actual commits (we all do...), and cannot reasonably ammend them, add all formatting changes at the end in a single commit with the message:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"git commit -m \"chore: formatting\"","category":"page"},{"location":"pages/dev_docs/#Testing","page":"Developer Documentation","title":"Testing","text":"","category":"section"},{"location":"pages/dev_docs/#Running-tests-locally","page":"Developer Documentation","title":"Running tests locally","text":"","category":"section"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"Launch a new Julia REPL (hit Alt+J and then Alt+O in VSCode), enter Package mode (by pressing ] in your REPL, now showing (IESopt) pkg>), and then execute all tests by running:","category":"page"},{"location":"pages/dev_docs/","page":"Developer Documentation","title":"Developer Documentation","text":"(IESopt) pkg> test","category":"page"},{"location":"pages/user_guide/general/#General","page":"General","title":"General","text":"","category":"section"},{"location":"pages/user_guide/general/","page":"General","title":"General","text":"To be added.","category":"page"},{"location":"pages/user_guide/sectors/electricity/#Electricity","page":"Electricity","title":"Electricity","text":"","category":"section"},{"location":"pages/user_guide/sectors/electricity/","page":"Electricity","title":"Electricity","text":"To be added.","category":"page"},{"location":"pages/user_guide/sectors/gas/#Gas","page":"Gas","title":"Gas","text":"","category":"section"},{"location":"pages/user_guide/sectors/gas/","page":"Gas","title":"Gas","text":"To be added.","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/#Templates","page":"Templates","title":"Templates","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"\"Core Templates\" are pre- or user-defined templates, that group and/or reparameterize IESopt.jl CoreComponents, or even other Core Templates. They are used to define more complex building blocks, that can be used in the optimization model.","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/#General-structure","page":"Templates","title":"General structure","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"A Core Template is defined by a YAML file, ending in .iesopt.template.yaml, that may contain the following entries:","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"parameters (optional): a dictionary of parameters that can be used to reparameterize the template\nfunctions (optional): validate, prepare, and finalize functions, containing Julia code\nfiles (optional): files can be loaded here \"on demand\" similar to the top-level config","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"Further exactly one of the following entries is required:","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"components: a dictionary of components that are part of the template, or\ncomponent: a single component that is part of the template","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/#Example:-A-simple-template","page":"Templates","title":"Example: A simple template","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"parameters:\n  some_custom_param: null\n  another_one: 100.0\n  one_more: heat\n\ncomponents:\n  a_node:\n    type: Node\n\n  b_node:\n    type: Node","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"To be added (more details).","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/#manual_templates_validate","page":"Templates","title":"Validate","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"To be added (explanation).","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"validation: |\n  @check parameters[\"carrier\"] isa String\n  @check parameters[\"carrier\"] in [\"heat\", \"electricity\"]","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"To be added (more examples).","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/#manual_templates_prepare","page":"Templates","title":"Prepare","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"To be added (explanation).","category":"page"},{"location":"pages/user_guide/custom_functionality/templates/#manual_templates_finalize","page":"Templates","title":"Finalize","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/templates/","page":"Templates","title":"Templates","text":"To be added (explanation).","category":"page"},{"location":"pages/tutorials/setup/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"pages/tutorials/setup/","page":"Installation","title":"Installation","text":"To be added.","category":"page"},{"location":"pages/tutorials/setup/#Python","page":"Installation","title":"Python","text":"","category":"section"},{"location":"pages/tutorials/setup/","page":"Installation","title":"Installation","text":"To be added.","category":"page"},{"location":"pages/tutorials/setup/#Julia","page":"Installation","title":"Julia","text":"","category":"section"},{"location":"pages/tutorials/setup/","page":"Installation","title":"Installation","text":"To be added.","category":"page"},{"location":"pages/user_guide/custom_functionality/addons/#Addons","page":"Addons","title":"Addons","text":"","category":"section"},{"location":"pages/user_guide/custom_functionality/addons/","page":"Addons","title":"Addons","text":"To be added.","category":"page"},{"location":"pages/manual/yaml/#YAML-Reference","page":"YAML Reference","title":"YAML Reference","text":"","category":"section"},{"location":"pages/manual/yaml/","page":"YAML Reference","title":"YAML Reference","text":"To be added (based on docstrings from, e.g., the configs).","category":"page"},{"location":"pages/tutorials/results/#Result-extraction","page":"Result extraction","title":"Result extraction","text":"","category":"section"},{"location":"pages/tutorials/results/","page":"Result extraction","title":"Result extraction","text":"To be added.","category":"page"},{"location":"pages/changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"All notable changes to this project will be documented in this file.","category":"page"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.","category":"page"},{"location":"pages/changelog/#[1.0.0]-2023-06-01","page":"Changelog","title":"[1.0.0] - 2023-06-01","text":"","category":"section"},{"location":"pages/changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"pages/changelog/","page":"Changelog","title":"Changelog","text":"Initial public release of IESopt.jl","category":"page"},{"location":"pages/manual/core_components/#Model-Reference","page":"Model Reference","title":"Model Reference","text":"","category":"section"},{"location":"pages/manual/core_components/","page":"Model Reference","title":"Model Reference","text":"This page collects all information about the core components of IESopt, their properties (and default values), their internal mathematical formulations, and some examples of how to use them. See the API Reference for a complete list of all available functions and types.","category":"page"},{"location":"pages/manual/core_components/","page":"Model Reference","title":"Model Reference","text":"CurrentModule       = IESopt\nCollapsedDocStrings = true","category":"page"},{"location":"pages/manual/core_components/","page":"Model Reference","title":"Model Reference","text":"Connection\nDecision\nNode\nProfile\nUnit","category":"page"},{"location":"pages/manual/core_components/#IESopt.Connection","page":"Model Reference","title":"IESopt.Connection","text":"A Connection is used to model arbitrary flows of energy between Nodes. It allows for limits, costs, delays, ...\n\nParameters\n\nName Mandatory Values Default Description\nnode_from yes string - This Connection models a flow from node_from to node_to (both are Nodes).\nnode_to yes string - This Connection models a flow from node_from to node_to (both are Nodes).\n\nDetailed Model Reference\n\nVariables\n\ndetails: flow\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_connection\").var.flow# Python\nmodel.get_component(\"your_connection\").var.flowYou can find the full implementation and all details here: IESopt.jl.Add the variable representing the flow of this connection to the model. This can be accessed via connection.var.flow[t].Additionally, the flow gets \"injected\" at the Nodes that the connection is connecting, resulting inbeginaligned\n    textconnectionnode_fromtextinjection_t = textconnectionnode_fromtextinjection_t - textflow_t qquad forall t in T \n    textconnectionnode_totextinjection_t = textconnectionnode_totextinjection_t + textflow_t qquad forall t in T\nendalignedmathFor \"PF controlled\" Connections (ones that define the necessary power flow parameters), the flow variable may not be constructed (depending on specific power flow being used). The automatic result extraction will detect this and return the correct values either way. Accessing it manually can be done using connection.exp.pf_flow[t].\n\nExpressions\n\ndetails: pf_flow\ntip: How to?\nAccess this expression by using:# Julia\ncomponent(model, \"your_connection\").exp.pf_flow# Python\nmodel.get_component(\"your_connection\").exp.pf_flowYou can find the full implementation and all details here: IESopt.jl.Construct the JuMP.AffExpr holding the PTDF based flow of this Connection.This needs the global addon Powerflow with proper settings for mode, as well as properly configured power flow parameters for this Connection (pf_V, pf_I, pf_X, ...).\n\nConstraints\n\ndetails: flow_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_connection\").con.flow_bounds# Python\nmodel.get_component(\"your_connection\").con.flow_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of the flow (related to connection) to the model.Specifiying capacity will lead to symmetric bounds (textlb = -capacity and textub = capacity), while asymmetric bounds can be set by explicitly specifiying lb and ub.note: Note\nUsage of etdf is currently not fully tested, and not documented.Upper and lower bounds can be \"infinite\" (by not setting them) resulting in the repective constraints not being added, and the flow variable therefore being (partially) unconstrained. Depending on the configuration the flow is calculated differently:if connection.etdf is set, it is based on an ETDF sum flow,\nif connection.exp.pf_flow is available, it equals this\nelse it equal connection.var.flowThis flow is then constrained:beginaligned\n     textflow_t geq textlb qquad forall t in T \n     textflow_t leq textub qquad forall t in T\nendalignedmathnote: Constraint safety\nThe lower and upper bound constraint are subject to penalized slacks.\n\nObjectives\n\ndetails: cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_connection\").obj.cost# Python\nmodel.get_component(\"your_connection\").obj.costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this connection to the global objective function.The connection.cost setting introduces a fixed cost of \"transportation\" to the flow of this Connection. It is based on the directed flow. This means that flows in the \"opposite\" direction will lead to negative costs:sum_t in T textflow_t cdot textcost_t cdot omega_tmathHere omega_t is the weight of Snapshot t.note: Costs for flows in both directions\nIf you need to apply a cost term to the absolute value of the flow, consider splitting the Connection into two different ones, in opposing directions, and including lb = 0.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/core_components/#IESopt.Decision","page":"Model Reference","title":"IESopt.Decision","text":"A Decision represents a basic decision variable in the model that can be used as input for various other core component's settings, as well as have associated costs.\n\nParameters\n\nName Mandatory Values Default Description\nlb no numeric 0 Minimum size of the decision (considered for each \"unit\" if count allows multiple \"units\").\n\nDetailed Model Reference\n\nVariables\n\ndetails: fixed\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_decision\").var.fixed# Python\nmodel.get_component(\"your_decision\").var.fixedYou can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_decision\").var.sos# Python\nmodel.get_component(\"your_decision\").var.sosYou can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: value\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_decision\").var.value# Python\nmodel.get_component(\"your_decision\").var.valueYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the value of this decision to the model. If lower and upper bounds (decision.lb and decision.ub) are the same, the variable will immediately be fixed to that value. This can be accessed via decision.var.value.\n\nExpressions\n\nConstraints\n\ndetails: fixed\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.fixed# Python\nmodel.get_component(\"your_decision\").con.fixedYou can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos1\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.sos1# Python\nmodel.get_component(\"your_decision\").con.sos1You can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos2\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.sos2# Python\nmodel.get_component(\"your_decision\").con.sos2You can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos_value\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.sos_value# Python\nmodel.get_component(\"your_decision\").con.sos_valueYou can find the full implementation and all details here: IESopt.jl.to be added\n\nObjectives\n\ndetails: fixed\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_decision\").obj.fixed# Python\nmodel.get_component(\"your_decision\").obj.fixedYou can find the full implementation and all details here: IESopt.jl.\n\ndetails: sos\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_decision\").obj.sos# Python\nmodel.get_component(\"your_decision\").obj.sosYou can find the full implementation and all details here: IESopt.jl.Add the cost defined by the SOS-based value of this Decision to the model.\n\ndetails: value\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_decision\").obj.value# Python\nmodel.get_component(\"your_decision\").obj.valueYou can find the full implementation and all details here: IESopt.jl.Add the cost defined by the value of this Decision to the model:textvalue cdot textcostmath\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/core_components/#IESopt.Node","page":"Model Reference","title":"IESopt.Node","text":"A Node represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems). It enforces a nodal balance equation (= \"energy that flows into it must flow out\") for every Snapshot. Enabling the internal state of the Node allows it to act as energy storage, modifying the nodal balance equation. This allows using Nodes for various storage tasks (like batteries, hydro reservoirs, heat storages, ...). \n\ndetails: Basic Examples\nA Node that represents an electrical bus:bus:\n  type: Node\n  carrier: electricityA Node that represents a simplified hydrogen storage:store:\n  type: Node\n  carrier: hydrogen\n  has_state: true\n  state_lb: 0\n  state_ub: 50\n\nParameters\n\nName Mandatory Values Default Description\ncarrier yes string - Carrier of this Node. All connecting components need to respect that.\nhas_state no true or false false If true, the Node is considered to have an internal state (\"stateful Node\"). This allows it to act as energy storage. Connect Connections or Units to it, acting as charger/discharger.\nstate_lb no numeric -infty Lower bound of the internal state, requires has_state = true.\nstate_ub no numeric +infty Upper bound of the internal state, requires has_state = true.\nstate_cyclic no eq, geq, or disabled eq Controls how the state considers the boundary between last and first Snapshot. disabled disables cyclic behaviour of the state (see also state_initial), eq leads to the state at the end of the year being the initial state at the beginning of the year, while geq does the same while allowing the end-of-year state to be higher (= \"allowing to destroy energy at the end of the year\").\nstate_initial no numeric - Sets the initial state. Must be used in combination with state_cyclic = disabled.\nstate_final no numeric - Sets the final state. Must be used in combination with state_cyclic = disabled.\nstate_percentage_loss no numeric 0 Per Snapshot percentage loss of state (loosing 1% should be set as 0.01).\nnodal_balance no enforce, destroy, or create enforce Can only be used for has_state = false. enforce forces total injections to always be zero (similar to Kirchhoff's current law), create allows \"supply < demand\", destroy allows \"supply > demand\", at this Node.\nsum_window_size no integer - TODO.\nsum_window_step no integer 1 TODO.\n\nDetailed Model Reference\n\nVariables\n\ndetails: pf_theta\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_node\").var.pf_theta# Python\nmodel.get_component(\"your_node\").var.pf_thetaYou can find the full implementation and all details here: IESopt.jl.\n\ndetails: state\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_node\").var.state# Python\nmodel.get_component(\"your_node\").var.stateYou can find the full implementation and all details here: IESopt.jl.Add the variable representing the state of this node to the model, if node.has_state == true. This can be accessed via node.var.state[t].Additionally, if the state's initial value is specified via state_initial the following gets added:textstate_1 = textstate_initialmath\n\nExpressions\n\ndetails: injection\ntip: How to?\nAccess this expression by using:# Julia\ncomponent(model, \"your_node\").exp.injection# Python\nmodel.get_component(\"your_node\").exp.injectionYou can find the full implementation and all details here: IESopt.jl.Add an empty (JuMP.AffExpr(0)) expression to the node that keeps track of feed-in and withdrawal of energy.This constructs the expression textinjection_t forall t in T that is utilized in node.con.nodalbalance. Core components (Connections, Profiles, and Units) that feed energy into this node add to it, all others subtract from it. A stateless node forces this nodal balance to always equal 0 which essentially describes \"generation = demand\".\n\nConstraints\n\ndetails: last_state\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_node\").con.last_state# Python\nmodel.get_component(\"your_node\").con.last_stateYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of the node's state during the last Snapshot to the model, if node.has_state == true.This is necessary since it could otherwise happen, that the state following the last Snapshot is actually not feasible (e.g. we could charge a storage by more than it's state allows for). The equations are based on the construction of the overall state variable.beginaligned\n     textstate_end cdot textfactor^omega_t + textinjection_end cdot omega_t geq textstate_lb  \n     textstate_end cdot textfactor^omega_t + textinjection_end cdot omega_t leq textstate_ub \nendalignedmathHere omega_t is the weight of Snapshot t, and textfactor is either 1.0 (if there are now percentage losses configured), or (1.0 - node.state_percentage_loss) otherwise.note: Constraint safety\nThe lower and upper bound constraint are subject to penalized slacks.\n\ndetails: nodalbalance\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_node\").con.nodalbalance# Python\nmodel.get_component(\"your_node\").con.nodalbalanceYou can find the full implementation and all details here: IESopt.jl.Add the constraint describing the nodal balance to the model.Depending on whether the node is stateful or not, this constructs different representations:if node.has_state == truebeginaligned\n     textstate_t = textstate_t-1 cdot textfactor^omega_t-1 + textinjection_t-1 cdot omega_t-1 qquad forall t in T setminus 1 \n    \n     textstate_1 = textstate_end cdot textfactor^omega_end + textinjection_end cdot omega_end\nendalignedmathHere omega_t is the weight of Snapshot t, and textfactor is either 1.0 (if there are now percentage losses configured), or (1.0 - node.state_percentage_loss) otherwise. textinjection_t describes the overall injection (all feed-ins minus all withdrawals). end indicates the last snapshot in T. Depending on the setting of state_cyclic the second constraint is written as = (\"eq\") or leq (\"leq\"). The latter allows the destruction of excess energy at the end of the total time period to help with feasibility.if node.has_state == falsebeginaligned\n     textinjection_t = 0 qquad forall t in T \nendalignedmathThis equation can further be configured using the nodal_balance parameter, which accepts enforce (resulting in =), create (resulting in leq; allowing the creation of energy - or \"negative injections\"), and destroy ( resulting in geq; allowing the destruction of energy - or \"positive injections\"). This can be used to model some form of energy that can either be sold (using a destroy Profile connected to this Node), or \"wasted into the air\" using the destroy setting of this Node. \n\ndetails: state_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_node\").con.state_bounds# Python\nmodel.get_component(\"your_node\").con.state_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of the node's state to the model, if node.has_state == true.beginaligned\n     textstate_t geq textstate_lb qquad forall t in T \n     textstate_t leq textstate_ub qquad forall t in T\nendalignedmathnote: Constraint safety\nThe lower and upper bound constraint are subject to penalized slacks.\n\nObjectives\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/core_components/#IESopt.Profile","page":"Model Reference","title":"IESopt.Profile","text":"A Profile allows representing \"model boundaries\" - parts of initial problem that are not endogenously modelled - with a support for time series data. Examples are hydro reservoir inflows, electricity demand, importing gas, and so on. Besides modelling fixed profiles, they also allow different ways to modify the value endogenously.\n\nParameters\n\nName Mandatory Values Default Description\ncarrier yes string - Carrier of this Profile.\n\nDetailed Model Reference\n\nVariables\n\ndetails: aux_value\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_profile\").var.aux_value# Python\nmodel.get_component(\"your_profile\").var.aux_valueYou can find the full implementation and all details here: IESopt.jl.Add the variable that is used in this Profiles value to the model.The variable var_value[t] is constructed and is linked to the correct Nodes. There are different ways, IESopt interprets this, based on the setting of profile.mode:fixed: The value is already handled by the constant term of profile.exp.value and NO variable is constructed.\ncreate, destroy, or ranged: This models the creation or destruction of energy - used mainly to represent model boundaries, and energy that comes into the model or leaves the model's scope. It is however important that create should mostly be used feeding into a Node (profile.node_from = nothing) and destroy withdrawing from a Node (profile.node_to = nothing). If lb and ub are defined, ranged can be used that allows a more detailled control over the Profile, specifying upper and lower bounds for every Snapshot. See _profile_con_value_bounds!(profile::Profile) for details on the specific bounds for each case.This variable is added to the profile.exp.value. Additionally, the energy (that profile.exp.value represents) gets \"injected\" at the Nodes that the profile is connected to, resulting inbeginaligned\n    textprofilenode_fromtextinjection_t = textprofilenode_fromtextinjection_t - textvalue_t qquad forall t in T \n    textprofilenode_totextinjection_t = textprofilenode_totextinjection_t + textvalue_t qquad forall t in T\nendalignedmath\n\nExpressions\n\ndetails: value\ntip: How to?\nAccess this expression by using:# Julia\ncomponent(model, \"your_profile\").exp.value# Python\nmodel.get_component(\"your_profile\").exp.valueYou can find the full implementation and all details here: IESopt.jl.Cosntruct the JuMP.AffExpr that keeps the total value of this Profile for each Snapshot.This is skipped if the value of this Profile is handled by an Expression. Otherwise it is intialized based on profile.value.\n\nConstraints\n\ndetails: value_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_profile\").con.value_bounds# Python\nmodel.get_component(\"your_profile\").con.value_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of this profile to the model.This heavily depends on the mode setting, as it does nothing if the mode is set to fixed, or the value is actually controlled by an Expression. The variable can be accessed via profile.var.aux_value[t], but using the normal result extraction is recommended, since that properly handles the profile.exp.value instead.Otherwise:if profile.mode === :create or profile.mode === :destroybeginaligned\n     textaux_value_t geq 0 qquad forall t in T\nendalignedmathif profile.mode === :rangedbeginaligned\n     textvalue_t geq textlb_t qquad forall t in T \n     textvalue_t leq textub_t qquad forall t in T\nendalignedmathHere, lb and ub can be left empty, which drops the respective constraint.\n\nObjectives\n\ndetails: cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_profile\").obj.cost# Python\nmodel.get_component(\"your_profile\").obj.costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this Profile to the global objective function.The profile.cost setting specifies a potential cost for the creation (\"resource costs\", i.e. importing gas into the model) or destruction (\"penalties\", i.e. costs linked to the emission of CO2). It can have a unique value for every Snapshot, i.e. allowing to model a time-varying gas price throughout the year.The contribution to the global objective function is as follows:sum_tin T textvalue_t cdot textprofilecost_t cdot omega_tmathHere omega_t is the weight of Snapshot t, and textvalue_t actually refers to the value of profile.exp.value[t] (and not only on the maybe non-existing variable).\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/core_components/#IESopt.Unit","page":"Model Reference","title":"IESopt.Unit","text":"A Unit allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.\n\nParameters\n\nName Mandatory Values Default Description\nconversion yes string - The conversion expression describing how this Unit transforms energy. Specified in the form of \"alpha cdot carrier_1 + beta cdot carrier_2 -> gamma cdot carrier_3 + delta cdot carrier_4\". Coefficients allow simple numerical calculations, but are not allowed to include spaces (so e.g. (1.0/9.0) is valid). Coefficients are allowed to be NumericalInputs, resulting in column@data_file being a valid coefficient (this can be used e.g. for time-varying COPs of heatpumps).\ncapacity yes string - Maximum capacity of this Unit, to be given in the format X in/out:carrier where X is the amount, in or out (followed by :) specifies whether the limit is to be placed on the in- our output of this Unit, and carrier specifies the respective Carrier. Example: 100 in:electricity (to limit the \"input rating\").\n\nDetailed Model Reference\n\nVariables\n\ndetails: conversion\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.conversion# Python\nmodel.get_component(\"your_unit\").var.conversionYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the unit's conversion to the model.This can be accessed via unit.var.conversion[t]; this does not describe the full output of the Unit since that maybe also include fixed generation based on the ison variable.info: Info\nThis applies some heavy recalculation of efficiencies to account for minimum load and so on, that are currently not fully documented. This essentially comes down to the following: As long as minimum load is not enabled, that is rather simple (using the conversion expression to withdraw energy from the inputs and push energy into the outputs). If a separate minimum load conversion is specified it results in the following: (1) if running at minimum load the supplied minimum load conversion will be used; (2) if running at maximum capacity the \"normal\" conversion expression will be used; (3) for any point in-between a linear interpolation scales up all coefficients of the conversion expression to \"connect\" case (1) and (2).\n\ndetails: conversion_connect\nNo documentation found.IESopt._unit_var_conversion_connect! is a Function.tip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.conversion_connect# Python\nmodel.get_component(\"your_unit\").var.conversion_connectYou can find the full implementation and all details here: IESopt.jl.\n\ndetails: ison\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.ison# Python\nmodel.get_component(\"your_unit\").var.isonYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the current \"online\" state of the unit to the model.The variable can be further parameterized using the unit.unit_commitment setting (\"linear\", \"binary\", \"integer\"). It will automatically enforce the constraints 0 leq textison leq textunitcount, with textunitcount describing the number of units that are aggregated in this unit (set by unit.unit_count). This can be accessed via unit.var.ison[t].\n\ndetails: ramp\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.ramp# Python\nmodel.get_component(\"your_unit\").var.rampYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the per-snapshot ramping to the model.This adds two variables per snapshot to the model (if the respective setting unit.enable_ramp_up or unit.enable_ramp_down is activated). Both are preconstructed with a fixed lower bound of 0. This describes the amount of change in conversion that occurs during the current snapshot. These can be accessed via unit.var.ramp_up[t] and unit.var.ramp_down[t].These variables are only used for ramping costs. The limits are enforced directly on the conversion, which means this variable only exists if costs are specified!\n\ndetails: startup\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.startup# Python\nmodel.get_component(\"your_unit\").var.startupYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the per-snapshot startup to the model.This adds a variable per snapshot to the model (if the respective setting unit.unit_commitment is activated). The variable can be further parameterized using the unit.unit_commitment setting (\"linear\", \"binary\", \"integer\"). It will automatically enforce the constraints 0 leq textstartup leq textunitcount, with textunitcount describing the number of units that are aggregated in this unit (set by unit.unit_count). This describes the startup that happens during the current snapshot and can be accessed via unit.var.startup.\n\nExpressions\n\nConstraints\n\ndetails: conversion_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.conversion_bounds# Python\nmodel.get_component(\"your_unit\").con.conversion_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the unit's conversion bounds to the model.This makes use of the current min_capacity (describing the lower limit of conversion; either 0 if no minimum load applies or the respective value of the minimum load) as well as the online_capacity (that can either be the full capacity if unit commitment is disabled, or the amount that is currently active).Depending on how the \"availability\" of this unit is handled it constructs the following constraints:if !isnothing(unit.availability)beginaligned\n     textconversion_t geq textcapacity_textmin t qquad forall t in T \n     textconversion_t leq textcapacity_textonline t qquad forall t in T \n     textconversion_t leq textavailability_t qquad forall t in T\nendalignedmathThis effectively results in textconversion_t leq min(textcapacity_textonline t textavailability_t).if !isnothing(unit.availability_factor)beginaligned\n     textconversion_t geq textcapacity_textmin t qquad forall t in T \n     textconversion_t leq textcapacity_textonline t cdot textavailability_textfactor t qquad forall t in T\nendalignedmathinfo: Info\nIf one is able to choose between using availability or availability_factor (e.g. for restricting available capacity during a planned revision to half the units capacity), enabling availability_factor (in this example 0.5) will result in a faster model (build and probably solve) since it makes use of one less constraint.If no kind of availability limiting takes place, the following bounds are enforced:beginaligned\n     textconversion_t geq textcapacity_textmin t qquad forall t in T \n     textconversion_t leq textcapacity_textonline t qquad forall t in T\nendalignedmath\n\ndetails: ison\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.ison# Python\nmodel.get_component(\"your_unit\").con.isonYou can find the full implementation and all details here: IESopt.jl.Construct the upper bound for var_ison, based on unit.unit_count, if it is handled by an external Decision.\n\ndetails: min_onoff_time\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.min_onoff_time# Python\nmodel.get_component(\"your_unit\").con.min_onoff_timeYou can find the full implementation and all details here: IESopt.jl.Add the constraints modeling min on- or off-time of a Unit to the model.This constructs the constraintsbeginalign\n     sum_t = t^t + textmin_on_time ison_t = textmin_on_time cdot (ison_t - ison_t-1) qquad forall t in T \n     sum_t = t^t + textmin_off_time (1 - ison_t) = textmin_off_time cdot (ison_t-1 - ison_t) qquad forall t in T\nendalign\n\nrespecting on_time_before and off_time_before and is_on_before See the code for more details\n\n info Aggregated units\n    This is currently not fully adapted to account for Units with unit_count  1math\n\ndetails: ramp\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.ramp# Python\nmodel.get_component(\"your_unit\").con.rampYou can find the full implementation and all details here: IESopt.jl.Add the auxiliary constraint that enables calculation of per snapshot ramping to the model.Depending on whether ramps are enabled, none, one, or both of the following constraints are constructed:beginaligned\n     textramp_textup t geq textconversion_t - textconversion_t-1 qquad forall t in T \n     textramp_textdown t geq textconversion_t-1 - textconversion_t qquad forall t in T\nendalignedmathThis calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:out[5] = 100 and out[4] = 50, then ramp_up[5] = 50 and ramp_down[5] = 0\nramp_up[1] = ramp_down[1] = 0info: Info\nThis currently does not support pre-setting the initial states of the unit (it can be done manually but there is no exposed parameter), which will be implemented in the future to allow for easy / correct rolling optimization runs.\n\ndetails: ramp_limit\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.ramp_limit# Python\nmodel.get_component(\"your_unit\").con.ramp_limitYou can find the full implementation and all details here: IESopt.jl.Add the constraint describing the ramping limits of this unit to the model.This makes use of the maximum capacity of the unit, which is just the total installed capacity. Both, up- and downwards ramps can be enabled separately (via unit.ramp_up_limit and unit.ramp_down_limit), resulting in either or both of:beginaligned\n     textramp_textup t leq textramplimit_textup cdot textcapacity_textmax cdot omega_t qquad forall t in T \n     textramp_textdown t leq textramplimit_textdown cdot textcapacity_textmax cdot omega_t qquad forall t in T\nendalignedmathThis does not make use of the ramping variable (that is only used for costs - if there are costs).This calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:out[5] = 100 and out[4] = 50, then ramp_up[5] = 50 and ramp_down[5] = 0\nramp_up[1] = ramp_down[1] = 0\n\ndetails: startup\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.startup# Python\nmodel.get_component(\"your_unit\").con.startupYou can find the full implementation and all details here: IESopt.jl.Add the auxiliary constraint that enables calculation of per snapshot startup to the model.Depending on whether startup handling is enabled, the following constraint is constructed:beginaligned\n     textstartup_textup t geq textison_t - textison_t-1 qquad forall t in T\nendalignedmathThis calculates the startup that happens from the PREVIOUS snapshot to this one. That means that if:ison[5] = 1 and ison[4] = 0, then startup[5] = 1\n\nObjectives\n\ndetails: marginal_cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_unit\").obj.marginal_cost# Python\nmodel.get_component(\"your_unit\").obj.marginal_costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this unit's conversion (unit.marginal_cost) to the global objective function.sum_t in T textconversion_t cdot textmarginalcost_t cdot omega_tmath\n\ndetails: ramp_cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_unit\").obj.ramp_cost# Python\nmodel.get_component(\"your_unit\").obj.ramp_costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this unit's ramping to the global objective function.To allow for finer control, costs of up- and downwards ramping can be specified separately (using unit.ramp_up_cost and unit.ramp_down_cost):sum_t in T textramp_textup t cdot textrampcost_textup + textramp_textdown t cdot textrampcost_textdownmath\n\ndetails: startup_cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_unit\").obj.startup_cost# Python\nmodel.get_component(\"your_unit\").obj.startup_costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this unit's startup behaviour (configured by unit.startup_cost if unit.unit_commitment != :off).sum_t in T textstartup_t cdot textstartupcostmath\n\n\n\n\n\n","category":"type"},{"location":"pages/tutorials/first_model/#First-steps","page":"First steps","title":"First steps","text":"","category":"section"},{"location":"pages/tutorials/first_model/#Need-help?","page":"First steps","title":"Need help?","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added.","category":"page"},{"location":"pages/tutorials/first_model/#Overview","page":"First steps","title":"Overview","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"IESopt (the framework) consists of various sub-projects. It is a component-based optimization framework, where each component can be seen as block containing some predefined functionality. There are five \"core components\": Connection, Decision, Node, Profile, and Unit. These will be used to define arbitrary energy system models, similar to how a general commodity flow model works. Furthermore, they can be combined to create more complicated (non-core) components.","category":"page"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"In their most basic form, core components can be described as:","category":"page"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"A Connection is used to model arbitrary flows of energy between Nodes. It allows for limits, costs, delays, ...\nA Decision represents a basic decision variable in the model that can be used as input for various other core component's settings, as well as have associated costs.\nA Node represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems).\nA Profile allows representing exogenous functionality with a support for time series data.\nA Unit allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.","category":"page"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"For most models, the Units will pack the most raw functionality, while the other components represent the structure of the overall model.","category":"page"},{"location":"pages/tutorials/first_model/#Your-first-model","page":"First steps","title":"Your first model","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Model-config","page":"First steps","title":"Model config","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Energy-carriers","page":"First steps","title":"Energy carriers","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Model-components","page":"First steps","title":"Model components","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Final-config-file","page":"First steps","title":"Final config file","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Running-the-optimization","page":"First steps","title":"Running the optimization","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Extracting-results","page":"First steps","title":"Extracting results","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#General-result-structure","page":"First steps","title":"General result structure","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Changing-the-model-config","page":"First steps","title":"Changing the model config","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Adapting-components","page":"First steps","title":"Adapting components","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Analyzing-the-results","page":"First steps","title":"Analyzing the results","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Extracting-results-directly-into-pd.DataFrames","page":"First steps","title":"Extracting results directly into pd.DataFrames","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/tutorials/first_model/#Final-thoughts","page":"First steps","title":"Final thoughts","text":"","category":"section"},{"location":"pages/tutorials/first_model/","page":"First steps","title":"First steps","text":"To be added (translate from internal version).","category":"page"},{"location":"pages/manual/api/#API-Reference","page":"API Reference","title":"API Reference","text":"","category":"section"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"This contains the following raw documentation entries:","category":"page"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"Pages = [\"api.md\"]\nDepth = 2:4","category":"page"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"","category":"page"},{"location":"pages/manual/api/#Julia","page":"API Reference","title":"Julia","text":"","category":"section"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"CurrentModule       = IESopt\nCollapsedDocStrings = true","category":"page"},{"location":"pages/manual/api/#Modules","page":"API Reference","title":"Modules","text":"","category":"section"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"IESopt","category":"page"},{"location":"pages/manual/api/#IESopt.IESopt","page":"API Reference","title":"IESopt.IESopt","text":"IESopt\n\nA general purpose solver agnostic energy system optimization framework.\n\n\n\n\n\n","category":"module"},{"location":"pages/manual/api/#Types","page":"API Reference","title":"Types","text":"","category":"section"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"Carrier\nSnapshot","category":"page"},{"location":"pages/manual/api/#IESopt.Carrier","page":"API Reference","title":"IESopt.Carrier","text":"struct Carrier\n    name::String\n    unit::Union{String, Nothing}\nend\n\nRepresents a single (energy) carrier with a given name.\n\nThis is mostly used to represent various commodities that (easily) represent some form of energy (e.g. gas, water, ...), but also enables modelling commodities that are not (treated as) representing some type of energy (e.g. CO2). Specify unit to bind that carrier to an (arbitrary) unit that allows easier plotting and result analysis.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/#IESopt.Snapshot","page":"API Reference","title":"IESopt.Snapshot","text":"struct Snapshot\n    name\n    id\n    weight\nend\n\nRepresent a specific timestamp, that can be tied to timeseries values.\n\nEach Snapshot expects a name, that can be used to hold a timestamp (as String; therefore supporting arbitrary formats). The weight (default = 1.0) specifies the \"probabilistic weight\" of this Snapshot or the length of the timeperiod that begins there (a weight of 2 can therefore represent a 2-hour-resolution; this also allows a variable temporal resolution throughout the year/month/...).\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"Connection\nDecision\nNode\nProfile\nUnit","category":"page"},{"location":"pages/manual/api/#IESopt.Connection-pages-manual-api","page":"API Reference","title":"IESopt.Connection","text":"A Connection is used to model arbitrary flows of energy between Nodes. It allows for limits, costs, delays, ...\n\nParameters\n\nName Mandatory Values Default Description\nnode_from yes string - This Connection models a flow from node_from to node_to (both are Nodes).\nnode_to yes string - This Connection models a flow from node_from to node_to (both are Nodes).\n\nDetailed Model Reference\n\nVariables\n\ndetails: flow\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_connection\").var.flow# Python\nmodel.get_component(\"your_connection\").var.flowYou can find the full implementation and all details here: IESopt.jl.Add the variable representing the flow of this connection to the model. This can be accessed via connection.var.flow[t].Additionally, the flow gets \"injected\" at the Nodes that the connection is connecting, resulting inbeginaligned\n    textconnectionnode_fromtextinjection_t = textconnectionnode_fromtextinjection_t - textflow_t qquad forall t in T \n    textconnectionnode_totextinjection_t = textconnectionnode_totextinjection_t + textflow_t qquad forall t in T\nendalignedmathFor \"PF controlled\" Connections (ones that define the necessary power flow parameters), the flow variable may not be constructed (depending on specific power flow being used). The automatic result extraction will detect this and return the correct values either way. Accessing it manually can be done using connection.exp.pf_flow[t].\n\nExpressions\n\ndetails: pf_flow\ntip: How to?\nAccess this expression by using:# Julia\ncomponent(model, \"your_connection\").exp.pf_flow# Python\nmodel.get_component(\"your_connection\").exp.pf_flowYou can find the full implementation and all details here: IESopt.jl.Construct the JuMP.AffExpr holding the PTDF based flow of this Connection.This needs the global addon Powerflow with proper settings for mode, as well as properly configured power flow parameters for this Connection (pf_V, pf_I, pf_X, ...).\n\nConstraints\n\ndetails: flow_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_connection\").con.flow_bounds# Python\nmodel.get_component(\"your_connection\").con.flow_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of the flow (related to connection) to the model.Specifiying capacity will lead to symmetric bounds (textlb = -capacity and textub = capacity), while asymmetric bounds can be set by explicitly specifiying lb and ub.note: Note\nUsage of etdf is currently not fully tested, and not documented.Upper and lower bounds can be \"infinite\" (by not setting them) resulting in the repective constraints not being added, and the flow variable therefore being (partially) unconstrained. Depending on the configuration the flow is calculated differently:if connection.etdf is set, it is based on an ETDF sum flow,\nif connection.exp.pf_flow is available, it equals this\nelse it equal connection.var.flowThis flow is then constrained:beginaligned\n     textflow_t geq textlb qquad forall t in T \n     textflow_t leq textub qquad forall t in T\nendalignedmathnote: Constraint safety\nThe lower and upper bound constraint are subject to penalized slacks.\n\nObjectives\n\ndetails: cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_connection\").obj.cost# Python\nmodel.get_component(\"your_connection\").obj.costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this connection to the global objective function.The connection.cost setting introduces a fixed cost of \"transportation\" to the flow of this Connection. It is based on the directed flow. This means that flows in the \"opposite\" direction will lead to negative costs:sum_t in T textflow_t cdot textcost_t cdot omega_tmathHere omega_t is the weight of Snapshot t.note: Costs for flows in both directions\nIf you need to apply a cost term to the absolute value of the flow, consider splitting the Connection into two different ones, in opposing directions, and including lb = 0.\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/#IESopt.Decision-pages-manual-api","page":"API Reference","title":"IESopt.Decision","text":"A Decision represents a basic decision variable in the model that can be used as input for various other core component's settings, as well as have associated costs.\n\nParameters\n\nName Mandatory Values Default Description\nlb no numeric 0 Minimum size of the decision (considered for each \"unit\" if count allows multiple \"units\").\n\nDetailed Model Reference\n\nVariables\n\ndetails: fixed\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_decision\").var.fixed# Python\nmodel.get_component(\"your_decision\").var.fixedYou can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_decision\").var.sos# Python\nmodel.get_component(\"your_decision\").var.sosYou can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: value\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_decision\").var.value# Python\nmodel.get_component(\"your_decision\").var.valueYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the value of this decision to the model. If lower and upper bounds (decision.lb and decision.ub) are the same, the variable will immediately be fixed to that value. This can be accessed via decision.var.value.\n\nExpressions\n\nConstraints\n\ndetails: fixed\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.fixed# Python\nmodel.get_component(\"your_decision\").con.fixedYou can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos1\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.sos1# Python\nmodel.get_component(\"your_decision\").con.sos1You can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos2\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.sos2# Python\nmodel.get_component(\"your_decision\").con.sos2You can find the full implementation and all details here: IESopt.jl.to be added\n\ndetails: sos_value\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_decision\").con.sos_value# Python\nmodel.get_component(\"your_decision\").con.sos_valueYou can find the full implementation and all details here: IESopt.jl.to be added\n\nObjectives\n\ndetails: fixed\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_decision\").obj.fixed# Python\nmodel.get_component(\"your_decision\").obj.fixedYou can find the full implementation and all details here: IESopt.jl.\n\ndetails: sos\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_decision\").obj.sos# Python\nmodel.get_component(\"your_decision\").obj.sosYou can find the full implementation and all details here: IESopt.jl.Add the cost defined by the SOS-based value of this Decision to the model.\n\ndetails: value\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_decision\").obj.value# Python\nmodel.get_component(\"your_decision\").obj.valueYou can find the full implementation and all details here: IESopt.jl.Add the cost defined by the value of this Decision to the model:textvalue cdot textcostmath\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/#IESopt.Node-pages-manual-api","page":"API Reference","title":"IESopt.Node","text":"A Node represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems). It enforces a nodal balance equation (= \"energy that flows into it must flow out\") for every Snapshot. Enabling the internal state of the Node allows it to act as energy storage, modifying the nodal balance equation. This allows using Nodes for various storage tasks (like batteries, hydro reservoirs, heat storages, ...). \n\ndetails: Basic Examples\nA Node that represents an electrical bus:bus:\n  type: Node\n  carrier: electricityA Node that represents a simplified hydrogen storage:store:\n  type: Node\n  carrier: hydrogen\n  has_state: true\n  state_lb: 0\n  state_ub: 50\n\nParameters\n\nName Mandatory Values Default Description\ncarrier yes string - Carrier of this Node. All connecting components need to respect that.\nhas_state no true or false false If true, the Node is considered to have an internal state (\"stateful Node\"). This allows it to act as energy storage. Connect Connections or Units to it, acting as charger/discharger.\nstate_lb no numeric -infty Lower bound of the internal state, requires has_state = true.\nstate_ub no numeric +infty Upper bound of the internal state, requires has_state = true.\nstate_cyclic no eq, geq, or disabled eq Controls how the state considers the boundary between last and first Snapshot. disabled disables cyclic behaviour of the state (see also state_initial), eq leads to the state at the end of the year being the initial state at the beginning of the year, while geq does the same while allowing the end-of-year state to be higher (= \"allowing to destroy energy at the end of the year\").\nstate_initial no numeric - Sets the initial state. Must be used in combination with state_cyclic = disabled.\nstate_final no numeric - Sets the final state. Must be used in combination with state_cyclic = disabled.\nstate_percentage_loss no numeric 0 Per Snapshot percentage loss of state (loosing 1% should be set as 0.01).\nnodal_balance no enforce, destroy, or create enforce Can only be used for has_state = false. enforce forces total injections to always be zero (similar to Kirchhoff's current law), create allows \"supply < demand\", destroy allows \"supply > demand\", at this Node.\nsum_window_size no integer - TODO.\nsum_window_step no integer 1 TODO.\n\nDetailed Model Reference\n\nVariables\n\ndetails: pf_theta\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_node\").var.pf_theta# Python\nmodel.get_component(\"your_node\").var.pf_thetaYou can find the full implementation and all details here: IESopt.jl.\n\ndetails: state\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_node\").var.state# Python\nmodel.get_component(\"your_node\").var.stateYou can find the full implementation and all details here: IESopt.jl.Add the variable representing the state of this node to the model, if node.has_state == true. This can be accessed via node.var.state[t].Additionally, if the state's initial value is specified via state_initial the following gets added:textstate_1 = textstate_initialmath\n\nExpressions\n\ndetails: injection\ntip: How to?\nAccess this expression by using:# Julia\ncomponent(model, \"your_node\").exp.injection# Python\nmodel.get_component(\"your_node\").exp.injectionYou can find the full implementation and all details here: IESopt.jl.Add an empty (JuMP.AffExpr(0)) expression to the node that keeps track of feed-in and withdrawal of energy.This constructs the expression textinjection_t forall t in T that is utilized in node.con.nodalbalance. Core components (Connections, Profiles, and Units) that feed energy into this node add to it, all others subtract from it. A stateless node forces this nodal balance to always equal 0 which essentially describes \"generation = demand\".\n\nConstraints\n\ndetails: last_state\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_node\").con.last_state# Python\nmodel.get_component(\"your_node\").con.last_stateYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of the node's state during the last Snapshot to the model, if node.has_state == true.This is necessary since it could otherwise happen, that the state following the last Snapshot is actually not feasible (e.g. we could charge a storage by more than it's state allows for). The equations are based on the construction of the overall state variable.beginaligned\n     textstate_end cdot textfactor^omega_t + textinjection_end cdot omega_t geq textstate_lb  \n     textstate_end cdot textfactor^omega_t + textinjection_end cdot omega_t leq textstate_ub \nendalignedmathHere omega_t is the weight of Snapshot t, and textfactor is either 1.0 (if there are now percentage losses configured), or (1.0 - node.state_percentage_loss) otherwise.note: Constraint safety\nThe lower and upper bound constraint are subject to penalized slacks.\n\ndetails: nodalbalance\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_node\").con.nodalbalance# Python\nmodel.get_component(\"your_node\").con.nodalbalanceYou can find the full implementation and all details here: IESopt.jl.Add the constraint describing the nodal balance to the model.Depending on whether the node is stateful or not, this constructs different representations:if node.has_state == truebeginaligned\n     textstate_t = textstate_t-1 cdot textfactor^omega_t-1 + textinjection_t-1 cdot omega_t-1 qquad forall t in T setminus 1 \n    \n     textstate_1 = textstate_end cdot textfactor^omega_end + textinjection_end cdot omega_end\nendalignedmathHere omega_t is the weight of Snapshot t, and textfactor is either 1.0 (if there are now percentage losses configured), or (1.0 - node.state_percentage_loss) otherwise. textinjection_t describes the overall injection (all feed-ins minus all withdrawals). end indicates the last snapshot in T. Depending on the setting of state_cyclic the second constraint is written as = (\"eq\") or leq (\"leq\"). The latter allows the destruction of excess energy at the end of the total time period to help with feasibility.if node.has_state == falsebeginaligned\n     textinjection_t = 0 qquad forall t in T \nendalignedmathThis equation can further be configured using the nodal_balance parameter, which accepts enforce (resulting in =), create (resulting in leq; allowing the creation of energy - or \"negative injections\"), and destroy ( resulting in geq; allowing the destruction of energy - or \"positive injections\"). This can be used to model some form of energy that can either be sold (using a destroy Profile connected to this Node), or \"wasted into the air\" using the destroy setting of this Node. \n\ndetails: state_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_node\").con.state_bounds# Python\nmodel.get_component(\"your_node\").con.state_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of the node's state to the model, if node.has_state == true.beginaligned\n     textstate_t geq textstate_lb qquad forall t in T \n     textstate_t leq textstate_ub qquad forall t in T\nendalignedmathnote: Constraint safety\nThe lower and upper bound constraint are subject to penalized slacks.\n\nObjectives\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/#IESopt.Profile-pages-manual-api","page":"API Reference","title":"IESopt.Profile","text":"A Profile allows representing \"model boundaries\" - parts of initial problem that are not endogenously modelled - with a support for time series data. Examples are hydro reservoir inflows, electricity demand, importing gas, and so on. Besides modelling fixed profiles, they also allow different ways to modify the value endogenously.\n\nParameters\n\nName Mandatory Values Default Description\ncarrier yes string - Carrier of this Profile.\n\nDetailed Model Reference\n\nVariables\n\ndetails: aux_value\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_profile\").var.aux_value# Python\nmodel.get_component(\"your_profile\").var.aux_valueYou can find the full implementation and all details here: IESopt.jl.Add the variable that is used in this Profiles value to the model.The variable var_value[t] is constructed and is linked to the correct Nodes. There are different ways, IESopt interprets this, based on the setting of profile.mode:fixed: The value is already handled by the constant term of profile.exp.value and NO variable is constructed.\ncreate, destroy, or ranged: This models the creation or destruction of energy - used mainly to represent model boundaries, and energy that comes into the model or leaves the model's scope. It is however important that create should mostly be used feeding into a Node (profile.node_from = nothing) and destroy withdrawing from a Node (profile.node_to = nothing). If lb and ub are defined, ranged can be used that allows a more detailled control over the Profile, specifying upper and lower bounds for every Snapshot. See _profile_con_value_bounds!(profile::Profile) for details on the specific bounds for each case.This variable is added to the profile.exp.value. Additionally, the energy (that profile.exp.value represents) gets \"injected\" at the Nodes that the profile is connected to, resulting inbeginaligned\n    textprofilenode_fromtextinjection_t = textprofilenode_fromtextinjection_t - textvalue_t qquad forall t in T \n    textprofilenode_totextinjection_t = textprofilenode_totextinjection_t + textvalue_t qquad forall t in T\nendalignedmath\n\nExpressions\n\ndetails: value\ntip: How to?\nAccess this expression by using:# Julia\ncomponent(model, \"your_profile\").exp.value# Python\nmodel.get_component(\"your_profile\").exp.valueYou can find the full implementation and all details here: IESopt.jl.Cosntruct the JuMP.AffExpr that keeps the total value of this Profile for each Snapshot.This is skipped if the value of this Profile is handled by an Expression. Otherwise it is intialized based on profile.value.\n\nConstraints\n\ndetails: value_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_profile\").con.value_bounds# Python\nmodel.get_component(\"your_profile\").con.value_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the bounds of this profile to the model.This heavily depends on the mode setting, as it does nothing if the mode is set to fixed, or the value is actually controlled by an Expression. The variable can be accessed via profile.var.aux_value[t], but using the normal result extraction is recommended, since that properly handles the profile.exp.value instead.Otherwise:if profile.mode === :create or profile.mode === :destroybeginaligned\n     textaux_value_t geq 0 qquad forall t in T\nendalignedmathif profile.mode === :rangedbeginaligned\n     textvalue_t geq textlb_t qquad forall t in T \n     textvalue_t leq textub_t qquad forall t in T\nendalignedmathHere, lb and ub can be left empty, which drops the respective constraint.\n\nObjectives\n\ndetails: cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_profile\").obj.cost# Python\nmodel.get_component(\"your_profile\").obj.costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this Profile to the global objective function.The profile.cost setting specifies a potential cost for the creation (\"resource costs\", i.e. importing gas into the model) or destruction (\"penalties\", i.e. costs linked to the emission of CO2). It can have a unique value for every Snapshot, i.e. allowing to model a time-varying gas price throughout the year.The contribution to the global objective function is as follows:sum_tin T textvalue_t cdot textprofilecost_t cdot omega_tmathHere omega_t is the weight of Snapshot t, and textvalue_t actually refers to the value of profile.exp.value[t] (and not only on the maybe non-existing variable).\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/#IESopt.Unit-pages-manual-api","page":"API Reference","title":"IESopt.Unit","text":"A Unit allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.\n\nParameters\n\nName Mandatory Values Default Description\nconversion yes string - The conversion expression describing how this Unit transforms energy. Specified in the form of \"alpha cdot carrier_1 + beta cdot carrier_2 -> gamma cdot carrier_3 + delta cdot carrier_4\". Coefficients allow simple numerical calculations, but are not allowed to include spaces (so e.g. (1.0/9.0) is valid). Coefficients are allowed to be NumericalInputs, resulting in column@data_file being a valid coefficient (this can be used e.g. for time-varying COPs of heatpumps).\ncapacity yes string - Maximum capacity of this Unit, to be given in the format X in/out:carrier where X is the amount, in or out (followed by :) specifies whether the limit is to be placed on the in- our output of this Unit, and carrier specifies the respective Carrier. Example: 100 in:electricity (to limit the \"input rating\").\n\nDetailed Model Reference\n\nVariables\n\ndetails: conversion\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.conversion# Python\nmodel.get_component(\"your_unit\").var.conversionYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the unit's conversion to the model.This can be accessed via unit.var.conversion[t]; this does not describe the full output of the Unit since that maybe also include fixed generation based on the ison variable.info: Info\nThis applies some heavy recalculation of efficiencies to account for minimum load and so on, that are currently not fully documented. This essentially comes down to the following: As long as minimum load is not enabled, that is rather simple (using the conversion expression to withdraw energy from the inputs and push energy into the outputs). If a separate minimum load conversion is specified it results in the following: (1) if running at minimum load the supplied minimum load conversion will be used; (2) if running at maximum capacity the \"normal\" conversion expression will be used; (3) for any point in-between a linear interpolation scales up all coefficients of the conversion expression to \"connect\" case (1) and (2).\n\ndetails: conversion_connect\nNo documentation found.IESopt._unit_var_conversion_connect! is a Function.tip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.conversion_connect# Python\nmodel.get_component(\"your_unit\").var.conversion_connectYou can find the full implementation and all details here: IESopt.jl.\n\ndetails: ison\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.ison# Python\nmodel.get_component(\"your_unit\").var.isonYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the current \"online\" state of the unit to the model.The variable can be further parameterized using the unit.unit_commitment setting (\"linear\", \"binary\", \"integer\"). It will automatically enforce the constraints 0 leq textison leq textunitcount, with textunitcount describing the number of units that are aggregated in this unit (set by unit.unit_count). This can be accessed via unit.var.ison[t].\n\ndetails: ramp\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.ramp# Python\nmodel.get_component(\"your_unit\").var.rampYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the per-snapshot ramping to the model.This adds two variables per snapshot to the model (if the respective setting unit.enable_ramp_up or unit.enable_ramp_down is activated). Both are preconstructed with a fixed lower bound of 0. This describes the amount of change in conversion that occurs during the current snapshot. These can be accessed via unit.var.ramp_up[t] and unit.var.ramp_down[t].These variables are only used for ramping costs. The limits are enforced directly on the conversion, which means this variable only exists if costs are specified!\n\ndetails: startup\ntip: How to?\nAccess this variable by using:# Julia\ncomponent(model, \"your_unit\").var.startup# Python\nmodel.get_component(\"your_unit\").var.startupYou can find the full implementation and all details here: IESopt.jl.Add the variable describing the per-snapshot startup to the model.This adds a variable per snapshot to the model (if the respective setting unit.unit_commitment is activated). The variable can be further parameterized using the unit.unit_commitment setting (\"linear\", \"binary\", \"integer\"). It will automatically enforce the constraints 0 leq textstartup leq textunitcount, with textunitcount describing the number of units that are aggregated in this unit (set by unit.unit_count). This describes the startup that happens during the current snapshot and can be accessed via unit.var.startup.\n\nExpressions\n\nConstraints\n\ndetails: conversion_bounds\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.conversion_bounds# Python\nmodel.get_component(\"your_unit\").con.conversion_boundsYou can find the full implementation and all details here: IESopt.jl.Add the constraint defining the unit's conversion bounds to the model.This makes use of the current min_capacity (describing the lower limit of conversion; either 0 if no minimum load applies or the respective value of the minimum load) as well as the online_capacity (that can either be the full capacity if unit commitment is disabled, or the amount that is currently active).Depending on how the \"availability\" of this unit is handled it constructs the following constraints:if !isnothing(unit.availability)beginaligned\n     textconversion_t geq textcapacity_textmin t qquad forall t in T \n     textconversion_t leq textcapacity_textonline t qquad forall t in T \n     textconversion_t leq textavailability_t qquad forall t in T\nendalignedmathThis effectively results in textconversion_t leq min(textcapacity_textonline t textavailability_t).if !isnothing(unit.availability_factor)beginaligned\n     textconversion_t geq textcapacity_textmin t qquad forall t in T \n     textconversion_t leq textcapacity_textonline t cdot textavailability_textfactor t qquad forall t in T\nendalignedmathinfo: Info\nIf one is able to choose between using availability or availability_factor (e.g. for restricting available capacity during a planned revision to half the units capacity), enabling availability_factor (in this example 0.5) will result in a faster model (build and probably solve) since it makes use of one less constraint.If no kind of availability limiting takes place, the following bounds are enforced:beginaligned\n     textconversion_t geq textcapacity_textmin t qquad forall t in T \n     textconversion_t leq textcapacity_textonline t qquad forall t in T\nendalignedmath\n\ndetails: ison\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.ison# Python\nmodel.get_component(\"your_unit\").con.isonYou can find the full implementation and all details here: IESopt.jl.Construct the upper bound for var_ison, based on unit.unit_count, if it is handled by an external Decision.\n\ndetails: min_onoff_time\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.min_onoff_time# Python\nmodel.get_component(\"your_unit\").con.min_onoff_timeYou can find the full implementation and all details here: IESopt.jl.Add the constraints modeling min on- or off-time of a Unit to the model.This constructs the constraintsbeginalign\n     sum_t = t^t + textmin_on_time ison_t = textmin_on_time cdot (ison_t - ison_t-1) qquad forall t in T \n     sum_t = t^t + textmin_off_time (1 - ison_t) = textmin_off_time cdot (ison_t-1 - ison_t) qquad forall t in T\nendalign\n\nrespecting on_time_before and off_time_before and is_on_before See the code for more details\n\n info Aggregated units\n    This is currently not fully adapted to account for Units with unit_count  1math\n\ndetails: ramp\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.ramp# Python\nmodel.get_component(\"your_unit\").con.rampYou can find the full implementation and all details here: IESopt.jl.Add the auxiliary constraint that enables calculation of per snapshot ramping to the model.Depending on whether ramps are enabled, none, one, or both of the following constraints are constructed:beginaligned\n     textramp_textup t geq textconversion_t - textconversion_t-1 qquad forall t in T \n     textramp_textdown t geq textconversion_t-1 - textconversion_t qquad forall t in T\nendalignedmathThis calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:out[5] = 100 and out[4] = 50, then ramp_up[5] = 50 and ramp_down[5] = 0\nramp_up[1] = ramp_down[1] = 0info: Info\nThis currently does not support pre-setting the initial states of the unit (it can be done manually but there is no exposed parameter), which will be implemented in the future to allow for easy / correct rolling optimization runs.\n\ndetails: ramp_limit\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.ramp_limit# Python\nmodel.get_component(\"your_unit\").con.ramp_limitYou can find the full implementation and all details here: IESopt.jl.Add the constraint describing the ramping limits of this unit to the model.This makes use of the maximum capacity of the unit, which is just the total installed capacity. Both, up- and downwards ramps can be enabled separately (via unit.ramp_up_limit and unit.ramp_down_limit), resulting in either or both of:beginaligned\n     textramp_textup t leq textramplimit_textup cdot textcapacity_textmax cdot omega_t qquad forall t in T \n     textramp_textdown t leq textramplimit_textdown cdot textcapacity_textmax cdot omega_t qquad forall t in T\nendalignedmathThis does not make use of the ramping variable (that is only used for costs - if there are costs).This calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:out[5] = 100 and out[4] = 50, then ramp_up[5] = 50 and ramp_down[5] = 0\nramp_up[1] = ramp_down[1] = 0\n\ndetails: startup\ntip: How to?\nAccess this constraint by using:# Julia\ncomponent(model, \"your_unit\").con.startup# Python\nmodel.get_component(\"your_unit\").con.startupYou can find the full implementation and all details here: IESopt.jl.Add the auxiliary constraint that enables calculation of per snapshot startup to the model.Depending on whether startup handling is enabled, the following constraint is constructed:beginaligned\n     textstartup_textup t geq textison_t - textison_t-1 qquad forall t in T\nendalignedmathThis calculates the startup that happens from the PREVIOUS snapshot to this one. That means that if:ison[5] = 1 and ison[4] = 0, then startup[5] = 1\n\nObjectives\n\ndetails: marginal_cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_unit\").obj.marginal_cost# Python\nmodel.get_component(\"your_unit\").obj.marginal_costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this unit's conversion (unit.marginal_cost) to the global objective function.sum_t in T textconversion_t cdot textmarginalcost_t cdot omega_tmath\n\ndetails: ramp_cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_unit\").obj.ramp_cost# Python\nmodel.get_component(\"your_unit\").obj.ramp_costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this unit's ramping to the global objective function.To allow for finer control, costs of up- and downwards ramping can be specified separately (using unit.ramp_up_cost and unit.ramp_down_cost):sum_t in T textramp_textup t cdot textrampcost_textup + textramp_textdown t cdot textrampcost_textdownmath\n\ndetails: startup_cost\ntip: How to?\nAccess this objective by using:# Julia\ncomponent(model, \"your_unit\").obj.startup_cost# Python\nmodel.get_component(\"your_unit\").obj.startup_costYou can find the full implementation and all details here: IESopt.jl.Add the (potential) cost of this unit's startup behaviour (configured by unit.startup_cost if unit.unit_commitment != :off).sum_t in T textstartup_t cdot textstartupcostmath\n\n\n\n\n\n","category":"type"},{"location":"pages/manual/api/#Functions","page":"API Reference","title":"Functions","text":"","category":"section"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"run\ngenerate!\noptimize!","category":"page"},{"location":"pages/manual/api/#IESopt.run","page":"API Reference","title":"IESopt.run","text":"run(filename::String; verbosity=nothing, kwargs...)\n\nBuild, optimize, and return a model.\n\nArguments\n\nfilename::String: The path to the top-level configuration file.\nverbosity: The verbosity level to use. Supports true (= verbose mode), \"warning\" (= warnings and above), and false (suppressing logs).\n\nIf verbosity = true, the verbosity setting of the solver defaults to true as well, otherwise it defaults to false (the verbosity setting of the solver can also be directly controled using the verbosity_solve setting in the top-level config file).\n\nKeyword Arguments\n\nKeyword arguments are passed to the generate! function.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/#IESopt.generate!","page":"API Reference","title":"IESopt.generate!","text":"generate!(filename::String)\n\nBuilds and returns a model using the IESopt framework.\n\nThis loads the configuration file specified by filename. Requires full specification of the solver entry in config.\n\n\n\n\n\ngenerate!(model::JuMP.Model, filename::String)\n\nBuilds a model using the IESopt framework, \"into\" the provided model.\n\nThis loads the configuration file specified by filename. Be careful when creating your model in any other way than in the provided examples, as this can conflict with IESopt internals (especially for model/optimizer combinations that do not support bridges). Returns the model for convenience, even though it is modified in place.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/#IESopt.optimize!","page":"API Reference","title":"IESopt.optimize!","text":"optimize!(model::JuMP.Model; save_results::Bool=true, kwargs...)\n\nUse JuMP.optimize! to optimize the given model, optionally serializing the model afterwards for later use.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"component","category":"page"},{"location":"pages/manual/api/#IESopt.component","page":"API Reference","title":"IESopt.component","text":"function component(model::JuMP.Model, component_name::String)\n\nGet the component component_name from model.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"compute_IIS","category":"page"},{"location":"pages/manual/api/#IESopt.compute_IIS","page":"API Reference","title":"IESopt.compute_IIS","text":"function compute_IIS(model::JuMP.Model; filename::String = \"\")\n\nCompute the IIS and print it. If filename is specified it will instead write all constraints to the given file. This will fail if the solver does not support IIS computation.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"overview\npack\nunpack","category":"page"},{"location":"pages/manual/api/#IESopt.overview","page":"API Reference","title":"IESopt.overview","text":"overview(file::String)\n\nExtracts the most important information from an IESopt model file, and returns it as a dictionary.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/#IESopt.pack","page":"API Reference","title":"IESopt.pack","text":"pack(file::String; out::String=\"\", method=:store)\n\nPacks the IESopt model specified by the top-level config file file into single file.\n\nThe out argument specifies the output file name. If not specified, a temporary file is created. Returns the output file name. The method argument specifies the compression method to use. The default is :store, which means no compression is used. The other option is :deflate, which uses the DEFLATE compression method. The default (:auto) applies :store to all files below 1 MB, :deflate otherwise.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/#IESopt.unpack","page":"API Reference","title":"IESopt.unpack","text":"unpack(file::String; out::String=\"\", force_overwrite::Bool=false)\n\nUnpacks the IESopt model specified by file.\n\nThe out argument specifies the output directory. If not specified, a temporary directory is created. Returns the path to the top-level config file. The force_overwrite argument specifies whether to overwrite existing files.\n\n\n\n\n\n","category":"function"},{"location":"pages/manual/api/#Python","page":"API Reference","title":"Python","text":"","category":"section"},{"location":"pages/manual/api/","page":"API Reference","title":"API Reference","text":"To be added.","category":"page"},{"location":"#IESopt.jl","page":"Home","title":"IESopt.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Integrated Energy System Optimization framework written in Julia.","category":"page"},{"location":"#Introduction","page":"Home","title":"Introduction","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IESopt.jl is the core of the IESopt framework, developed at AIT Austrian Institute of Technology GmbH. It is written in Julia, and uses JuMP package to construct the underlying mathematical optimization models, and to interface with various solvers. The model is designed to be modular, and allows for easy extension and customization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"# TODO: add \"The main functionalities of IESopt.jl are: ...\" itemize here.\n# TODO: add gitter here\n# TODO: cleanup the \"About\" section, and integrate it here","category":"page"},{"location":"","page":"Home","title":"Home","text":"Check out the following GitHub repositories for more information:","category":"page"},{"location":"","page":"Home","title":"Home","text":"IESopt.jl, the core model (a Julia package).\niesopt-py, the Python interface.","category":"page"},{"location":"","page":"Home","title":"Home","text":"danger: Moving to open-source\nWe are currently working (hard) on getting IESopt fully open-source on GitHub, which requires some clean-up of (potentially) confindential left-overs (e.g., from projects). Meanwhile, a lot of internals are changing (after staying fixed for a long time), and the documentation needs to be checked page-by-page. If you are trying to get started before we manage to fix everything, get in touch with us directly - we'll help you set up everything you need. The documentation currently consists of mostly structured pages, with the content being added as soon as possible.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"details: Using Python\nTo be added.","category":"page"},{"location":"","page":"Home","title":"Home","text":"details: Using Julia\nTo be added.","category":"page"},{"location":"#Citation","page":"Home","title":"Citation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you find IESopt useful in your work, and are intend to publish or document your modeling, we kindly request that you include the following citation:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Style: APA7\nStrömer, S., Schwabeneder, D., & contributors. (2021-2024). IESopt: Integrated Energy System Optimization [Software]. AIT Austrian Institute of Technology GmbH. https://github.com/ait-energy/IESopt\nStyle: IEEE\n[1] S. Strömer, D. Schwabeneder, and contributors, \"IESopt: Integrated Energy System Optimization,\" AIT Austrian Institute of Technology GmbH, 2021-2024. [Online]. Available: https://github.com/ait-energy/IESopt\nBibTeX:\n@misc{iesopt,\n    author = {Strömer, Stefan and Schwabeneder, Daniel and contributors},\n    title = {{IES}opt: Integrated Energy System Optimization},\n    organization = {AIT Austrian Institute of Technology GmbH},\n    url = {https://github.com/ait-energy/IESopt},\n    type = {Software},\n    year = {2021-2024},\n}","category":"page"},{"location":"","page":"Home","title":"Home","text":"# ## About\n\n# ### Overview\n\n# IESopt, _Integrated Energy System Optimization_, is a general purpose energy system optimization framework, developed at the [Center for Energy](https://www.ait.ac.at/en/about-the-ait/center/center-for-energy), at [AIT Austrian Institute of Technology GmbH](https://www.ait.ac.at/), mainly developed and maintained by the unit [Integrated Energy Systems](https://www.ait.ac.at/en/research-topics/integrated-energy-systems).\n\n# ### Feature summary\n\n# What IESopt is, may be, and is not:\n\n# - YES\n#   - IESopt is a general purpose energy system (optimization) model. It supports multiple solvers (using `JuMP.jl` to interface with them) as well as a standardized way to build up models using \"core components\".\n# - MAYBE\n#   - IESopt.jl is not branded as JuMP extension. It plays nicely with JuMP, and some extensions, but we currently do not see it as a fully fledged JuMP extension. That, e.g., entails that `copy_extension_data` is not implemented at the moment, so `copy_model` is not supported. This is a deliberate choice, and may be changed in the - near or far - future.\n# - NO (really ...)\n#   - A full energy system model, in the sense of \"containing data\". There are a lot of good, and open, data sources out there from other teams, consider using them.","category":"page"},{"location":"pages/user_guide/sectors/heat/#Heat","page":"Heat","title":"Heat","text":"","category":"section"},{"location":"pages/user_guide/sectors/heat/","page":"Heat","title":"Heat","text":"To be added.","category":"page"}]
}
