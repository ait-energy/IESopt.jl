<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model Reference · -- IESopt --</title><meta name="title" content="Model Reference · -- IESopt --"/><meta property="og:title" content="Model Reference · -- IESopt --"/><meta property="twitter:title" content="Model Reference · -- IESopt --"/><meta name="description" content="Documentation for -- IESopt --."/><meta property="og:description" content="Documentation for -- IESopt --."/><meta property="twitter:description" content="Documentation for -- IESopt --."/><meta property="og:url" content="https://ait-energy.github.io/IESopt.jl/pages/manual/core_components/"/><meta property="twitter:url" content="https://ait-energy.github.io/IESopt.jl/pages/manual/core_components/"/><link rel="canonical" href="https://ait-energy.github.io/IESopt.jl/pages/manual/core_components/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/base_template.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">-- IESopt --</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/setup/">Installation</a></li><li><a class="tocitem" href="../../tutorials/first_model/">First steps</a></li><li><a class="tocitem" href="../../tutorials/next_steps/">Next steps</a></li><li><a class="tocitem" href="../../tutorials/results/">Result extraction</a></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../user_guide/general/">General</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sectors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_guide/sectors/electricity/">Electricity</a></li><li><a class="tocitem" href="../../user_guide/sectors/heat/">Heat</a></li><li><a class="tocitem" href="../../user_guide/sectors/gas/">Gas</a></li></ul></li><li><a class="tocitem" href="../../user_guide/solvers/">Solvers</a></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Custom Functionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_guide/custom_functionality/templates/">Templates</a></li><li><a class="tocitem" href="../../user_guide/custom_functionality/addons/">Addons</a></li></ul></li><li><span class="tocitem">Examples</span></li></ul></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../yaml/">YAML Reference</a></li><li class="is-active"><a class="tocitem" href>Model Reference</a></li><li><a class="tocitem" href="../templates/">Template Reference</a></li><li><a class="tocitem" href="../api/">API Reference</a></li></ul></li><li><a class="tocitem" href="../../dev_docs/">Developer Documentation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Model Reference</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model Reference</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ait-energy/IESopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ait-energy/IESopt.jl/blob/dev/docs/src/pages/manual/core_components.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-Reference"><a class="docs-heading-anchor" href="#Model-Reference">Model Reference</a><a id="Model-Reference-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Reference" title="Permalink"></a></h1><p>This page collects all information about the core components of IESopt, their properties (and default values), their internal mathematical formulations, and some examples of how to use them. See the <a href="../api/#API-Reference">API Reference</a> for a complete list of all available functions and types.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Connection" href="#IESopt.Connection"><code>IESopt.Connection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Connection</code> is used to model arbitrary flows of energy between <code>Node</code>s. It allows for limits, costs, delays, ...</p><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>node_from</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">This <code>Connection</code> models a flow from <code>node_from</code> to <code>node_to</code> (both are <code>Node</code>s).</td></tr><tr><td style="text-align: left"><code>node_to</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">This <code>Connection</code> models a flow from <code>node_from</code> to <code>node_to</code> (both are <code>Node</code>s).</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">flow</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).var.flow</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).var.flow</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/var_flow.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable representing the flow of this <code>connection</code> to the <code>model</code>. This can be accessed via <code>connection.var.flow[t]</code>.</p><p>Additionally, the flow gets &quot;injected&quot; at the <code>Node</code>s that the <code>connection</code> is connecting, resulting in</p><p class="math-container">\[\begin{aligned}
   &amp; \text{connection.node}_{from}\text{.injection}_t = \text{connection.node}_{from}\text{.injection}_t - \text{flow}_t, \qquad \forall t \in T \\
   &amp; \text{connection.node}_{to}\text{.injection}_t = \text{connection.node}_{to}\text{.injection}_t + \text{flow}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><blockquote><p>For &quot;PF controlled&quot; <code>Connection</code>s (ones that define the necessary power flow parameters), the flow variable may not be constructed (depending on specific power flow being used). The automatic result extraction will detect this and return the correct values either way. Accessing it manually can be done using <code>connection.exp.pf_flow[t]</code>.</p></blockquote></div></details><p><strong>Expressions</strong></p><details class="admonition is-details"><summary class="admonition-header">pf_flow</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this expression by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).exp.pf_flow</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).exp.pf_flow</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/exp_pf_flow.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Construct the <code>JuMP.AffExpr</code> holding the PTDF based flow of this <code>Connection</code>.</p><p>This needs the global addon <code>Powerflow</code> with proper settings for <code>mode</code>, as well as properly configured power flow parameters for this <code>Connection</code> (<code>pf_V</code>, <code>pf_I</code>, <code>pf_X</code>, ...).</p></div></details><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">flow_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).con.flow_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).con.flow_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/con_flow_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of the flow (related to <code>connection</code>) to the <code>model</code>.</p><p>Specifiying <code>capacity</code> will lead to symmetric bounds (<span>$\text{lb} := -capacity$</span> and <span>$\text{ub} := capacity$</span>), while asymmetric bounds can be set by explicitly specifiying <code>lb</code> and <code>ub</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Usage of <code>etdf</code> is currently not fully tested, and not documented.</p></div></div><p>Upper and lower bounds can be &quot;infinite&quot; (by not setting them) resulting in the repective constraints not being added, and the flow variable therefore being (partially) unconstrained. Depending on the configuration the <code>flow</code> is calculated differently:</p><ul><li>if <code>connection.etdf</code> is set, it is based on an ETDF sum flow,</li><li>if <code>connection.exp.pf_flow</code> is available, it equals this</li><li>else it equal <code>connection.var.flow</code></li></ul><p>This flow is then constrained:</p><blockquote><p class="math-container">\[\begin{aligned}
    &amp; \text{flow}_t \geq \text{lb}, \qquad \forall t \in T \\
    &amp; \text{flow}_t \leq \text{ub}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><div class="admonition is-info"><header class="admonition-header">Constraint safety</header><div class="admonition-body"><p>The lower and upper bound constraint are subject to penalized slacks.</p></div></div></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).obj.cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).obj.cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/obj_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>connection</code> to the global objective function.</p><p>The <code>connection.cost</code> setting introduces a fixed cost of &quot;transportation&quot; to the flow of this <code>Connection</code>. It is based on the directed flow. This means that flows in the &quot;opposite&quot; direction will lead to negative costs:</p><p class="math-container">\[\sum_{t \in T} \text{flow}_t \cdot \text{cost}_t \cdot \omega_t\]</p><p>math</p><p>Here <span>$\omega_t$</span> is the weight of <code>Snapshot</code> <code>t</code>.</p><div class="admonition is-info"><header class="admonition-header">Costs for flows in both directions</header><div class="admonition-body"><p>If you need to apply a cost term to the absolute value of the flow, consider splitting the <code>Connection</code> into two different ones, in opposing directions, and including <code>lb = 0</code>.</p></div></div></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/f90d8d8a2a9ae8963808a92be6049946610c64d5/src/core/connection.jl#L1-L152">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Decision" href="#IESopt.Decision"><code>IESopt.Decision</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Decision</code> represents a basic decision variable in the model that can be used as input for various other core component&#39;s settings, as well as have associated costs.</p><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>lb</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Minimum size of the decision (considered for each &quot;unit&quot; if count allows multiple &quot;units&quot;).</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">fixed</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).var.fixed</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).var.fixed</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/var_fixed.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).var.sos</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).var.sos</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/var_sos.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).var.value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).var.value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/var_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the <code>value</code> of this <code>decision</code> to the <code>model</code>. If lower and upper bounds (<code>decision.lb</code> and <code>decision.ub</code>) are the same, the variable will immediately be fixed to that value. This can be accessed via <code>decision.var.value</code>.</p></div></details><p><strong>Expressions</strong></p><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">fixed</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.fixed</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.fixed</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_fixed.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos1</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.sos1</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.sos1</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_sos1.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos2</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.sos2</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.sos2</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_sos2.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos_value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.sos_value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.sos_value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_sos_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">fixed</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).obj.fixed</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).obj.fixed</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/obj_fixed.jl"><code>IESopt.jl</code></a>.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">sos</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).obj.sos</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).obj.sos</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/obj_sos.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the cost defined by the SOS-based value of this <code>Decision</code> to the <code>model</code>.</p></div></details><details class="admonition is-details"><summary class="admonition-header">value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).obj.value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).obj.value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/obj_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the cost defined by the value of this <code>Decision</code> to the <code>model</code>:</p><p class="math-container">\[\text{value} \cdot \text{cost}\]</p><p>math</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/f90d8d8a2a9ae8963808a92be6049946610c64d5/src/core/decision.jl#L1-L217">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Node" href="#IESopt.Node"><code>IESopt.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Node</code> represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems). It enforces a nodal balance equation (= &quot;energy that flows into it must flow out&quot;) for every <a href="../api/#IESopt.Snapshot"><code>Snapshot</code></a>. Enabling the internal state of the <code>Node</code> allows it to act as energy storage, modifying the nodal balance equation. This allows using <code>Node</code>s for various storage tasks (like batteries, hydro reservoirs, heat storages, ...). </p><details class="admonition is-details"><summary class="admonition-header">Basic Examples</summary><div class="admonition-body"><p>A <code>Node</code> that represents an electrical bus:</p><pre><code class="language-yaml hljs">bus:
  type: Node
  carrier: electricity</code></pre><p>A <code>Node</code> that represents a simplified hydrogen storage:</p><pre><code class="language-yaml hljs">store:
  type: Node
  carrier: hydrogen
  has_state: true
  state_lb: 0
  state_ub: 50</code></pre></div></details><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>carrier</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left"><code>Carrier</code> of this <code>Node</code>. All connecting components need to respect that.</td></tr><tr><td style="text-align: left"><code>has_state</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>true</code> or <code>false</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">If <code>true</code>, the <code>Node</code> is considered to have an internal state (&quot;stateful <code>Node</code>&quot;). This allows it to act as energy storage. Connect <code>Connection</code>s or <code>Unit</code>s to it, acting as charger/discharger.</td></tr><tr><td style="text-align: left"><code>state_lb</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left"><span>$-\infty$</span></td><td style="text-align: left">Lower bound of the internal state, requires <code>has_state = true</code>.</td></tr><tr><td style="text-align: left"><code>state_ub</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">Upper bound of the internal state, requires <code>has_state = true</code>.</td></tr><tr><td style="text-align: left"><code>state_cyclic</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>eq</code>, <code>geq</code>, or <code>disabled</code></td><td style="text-align: left"><code>eq</code></td><td style="text-align: left">Controls how the state considers the boundary between last and first <code>Snapshot</code>. <code>disabled</code> disables cyclic behaviour of the state (see also <code>state_initial</code>), <code>eq</code> leads to the state at the end of the year being the initial state at the beginning of the year, while <code>geq</code> does the same while allowing the end-of-year state to be higher (= &quot;allowing to destroy energy at the end of the year&quot;).</td></tr><tr><td style="text-align: left"><code>state_initial</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left">Sets the initial state. Must be used in combination with <code>state_cyclic = disabled</code>.</td></tr><tr><td style="text-align: left"><code>state_final</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left">Sets the final state. Must be used in combination with <code>state_cyclic = disabled</code>.</td></tr><tr><td style="text-align: left"><code>state_percentage_loss</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Per <code>Snapshot</code> percentage loss of state (loosing 1% should be set as <code>0.01</code>).</td></tr><tr><td style="text-align: left"><code>nodal_balance</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>enforce</code>, <code>destroy</code>, or <code>create</code></td><td style="text-align: left"><code>enforce</code></td><td style="text-align: left">Can only be used for <code>has_state = false</code>. <code>enforce</code> forces total injections to always be zero (similar to Kirchhoff&#39;s current law), <code>create</code> allows &quot;supply &lt; demand&quot;, <code>destroy</code> allows &quot;supply &gt; demand&quot;, at this <code>Node</code>.</td></tr><tr><td style="text-align: left"><code>sum_window_size</code></td><td style="text-align: left">no</td><td style="text-align: left">integer</td><td style="text-align: left">-</td><td style="text-align: left">TODO.</td></tr><tr><td style="text-align: left"><code>sum_window_step</code></td><td style="text-align: left">no</td><td style="text-align: left">integer</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">TODO.</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">pf_theta</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).var.pf_theta</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).var.pf_theta</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/var_pf_theta.jl"><code>IESopt.jl</code></a>.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">state</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).var.state</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).var.state</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/var_state.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable representing the state of this <code>node</code> to the <code>model</code>, if <code>node.has_state == true</code>. This can be accessed via <code>node.var.state[t]</code>.</p><p>Additionally, if the state&#39;s initial value is specified via <code>state_initial</code> the following gets added:</p><p class="math-container">\[\text{state}_1 = \text{state}_{initial}\]</p><p>math</p></div></details><p><strong>Expressions</strong></p><details class="admonition is-details"><summary class="admonition-header">injection</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this expression by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).exp.injection</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).exp.injection</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/exp_injection.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add an empty (<code>JuMP.AffExpr(0)</code>) expression to the <code>node</code> that keeps track of feed-in and withdrawal of energy.</p><p>This constructs the expression <span>$\text{injection}_t, \forall t \in T$</span> that is utilized in <code>node.con.nodalbalance</code>. Core components (<code>Connection</code>s, <code>Profile</code>s, and <code>Unit</code>s) that feed energy into this node add to it, all others subtract from it. A stateless node forces this nodal balance to always equal <code>0</code> which essentially describes &quot;generation = demand&quot;.</p></div></details><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">last_state</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).con.last_state</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).con.last_state</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/con_last_state.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of the <code>node</code>&#39;s state during the last Snapshot to the <code>model</code>, if <code>node.has_state == true</code>.</p><p>This is necessary since it could otherwise happen, that the state following the last Snapshot is actually not feasible (e.g. we could charge a storage by more than it&#39;s state allows for). The equations are based on the construction of the overall state variable.</p><p class="math-container">\[\begin{aligned}
    &amp; \text{state}_{end} \cdot \text{factor}^\omega_t + \text{injection}_{end} \cdot \omega_t \geq \text{state}_{lb} \\ 
    &amp; \text{state}_{end} \cdot \text{factor}^\omega_t + \text{injection}_{end} \cdot \omega_t \leq \text{state}_{ub} 
\end{aligned}\]</p><p>math</p><p>Here <span>$\omega_t$</span> is the <code>weight</code> of <code>Snapshot</code> <code>t</code>, and <span>$\text{factor}$</span> is either <code>1.0</code> (if there are now percentage losses configured), or <code>(1.0 - node.state_percentage_loss)</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Constraint safety</header><div class="admonition-body"><p>The lower and upper bound constraint are subject to penalized slacks.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">nodalbalance</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).con.nodalbalance</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).con.nodalbalance</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/con_nodalbalance.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint describing the nodal balance to the <code>model</code>.</p><p>Depending on whether the <code>node</code> is stateful or not, this constructs different representations:</p><blockquote><p><code>if node.has_state == true</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{state}_t = \text{state}_{t-1} \cdot \text{factor}^\omega_{t-1} + \text{injection}_{t-1} \cdot \omega_{t-1}, \qquad \forall t \in T \setminus \{1\} \\
    \\
    &amp; \text{state}_1 = \text{state}_{end} \cdot \text{factor}^\omega_{end} + \text{injection}_{end} \cdot \omega_{end}
\end{aligned}\]</p><p>math</p></blockquote><p>Here <span>$\omega_t$</span> is the <code>weight</code> of <code>Snapshot</code> <code>t</code>, and <span>$\text{factor}$</span> is either <code>1.0</code> (if there are now percentage losses configured), or <code>(1.0 - node.state_percentage_loss)</code> otherwise. <span>$\text{injection}_{t}$</span> describes the overall injection (all feed-ins minus all withdrawals). <span>$end$</span> indicates the last snapshot in <span>$T$</span>. Depending on the setting of <code>state_cyclic</code> the second constraint is written as <span>$=$</span> (<code>&quot;eq&quot;</code>) or <span>$\leq$</span> (<code>&quot;leq&quot;</code>). The latter allows the destruction of excess energy at the end of the total time period to help with feasibility.</p><blockquote><p><code>if node.has_state == false</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{injection}_{t} = 0, \qquad \forall t \in T \\
\end{aligned}\]</p><p>math</p></blockquote><p>This equation can further be configured using the <code>nodal_balance</code> parameter, which accepts <code>enforce</code> (resulting in <span>$=$</span>), <code>create</code> (resulting in <span>$\leq$</span>; allowing the creation of energy - or &quot;negative injections&quot;), and <code>destroy</code> ( resulting in <span>$\geq$</span>; allowing the destruction of energy - or &quot;positive injections&quot;). This can be used to model some form of energy that can either be sold (using a <code>destroy</code> <code>Profile</code> connected to this <code>Node</code>), or &quot;wasted into the air&quot; using the <code>destroy</code> setting of this <code>Node</code>. </p></div></details><details class="admonition is-details"><summary class="admonition-header">state_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).con.state_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).con.state_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/con_state_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of the <code>node</code>&#39;s state to the <code>model</code>, if <code>node.has_state == true</code>.</p><p class="math-container">\[\begin{aligned}
    &amp; \text{state}_t \geq \text{state}_{lb}, \qquad \forall t \in T \\
    &amp; \text{state}_t \leq \text{state}_{ub}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><div class="admonition is-info"><header class="admonition-header">Constraint safety</header><div class="admonition-body"><p>The lower and upper bound constraint are subject to penalized slacks.</p></div></div></div></details><p><strong>Objectives</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/f90d8d8a2a9ae8963808a92be6049946610c64d5/src/core/node.jl#L1-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Profile" href="#IESopt.Profile"><code>IESopt.Profile</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Profile</code> allows representing &quot;model boundaries&quot; - parts of initial problem that are not endogenously modelled - with a support for time series data. Examples are hydro reservoir inflows, electricity demand, importing gas, and so on. Besides modelling fixed profiles, they also allow different ways to modify the value endogenously.</p><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>carrier</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left"><code>Carrier</code> of this <code>Profile</code>.</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">aux_value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).var.aux_value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).var.aux_value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/var_aux_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable that is used in this <code>Profile</code>s value to the <code>model</code>.</p><p>The variable <code>var_value[t]</code> is constructed and is linked to the correct <code>Node</code>s. There are different ways, IESopt interprets this, based on the setting of <code>profile.mode</code>:</p><ol><li><strong>fixed</strong>: The value is already handled by the constant term of <code>profile.exp.value</code> and NO variable is constructed.</li><li><strong>create</strong>, <strong>destroy</strong>, or <strong>ranged</strong>: This models the creation or destruction of energy - used mainly to represent model boundaries, and energy that comes into the model or leaves the model&#39;s scope. It is however important that <code>create</code> should mostly be used feeding into a <code>Node</code> (<code>profile.node_from = nothing</code>) and <code>destroy</code> withdrawing from a <code>Node</code> (<code>profile.node_to = nothing</code>). If <code>lb</code> and <code>ub</code> are defined, <code>ranged</code> can be used that allows a more detailled control over the <code>Profile</code>, specifying upper and lower bounds for every <code>Snapshot</code>. See <code>_profile_con_value_bounds!(profile::Profile)</code> for details on the specific bounds for each case.</li></ol><p>This variable is added to the <code>profile.exp.value</code>. Additionally, the energy (that <code>profile.exp.value</code> represents) gets &quot;injected&quot; at the <code>Node</code>s that the <code>profile</code> is connected to, resulting in</p><p class="math-container">\[\begin{aligned}
   &amp; \text{profile.node}_{from}\text{.injection}_t = \text{profile.node}_{from}\text{.injection}_t - \text{value}_t, \qquad \forall t \in T \\
   &amp; \text{profile.node}_{to}\text{.injection}_t = \text{profile.node}_{to}\text{.injection}_t + \text{value}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></div></details><p><strong>Expressions</strong></p><details class="admonition is-details"><summary class="admonition-header">value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this expression by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).exp.value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).exp.value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/exp_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Cosntruct the <code>JuMP.AffExpr</code> that keeps the total value of this <code>Profile</code> for each <code>Snapshot</code>.</p><p>This is skipped if the <code>value</code> of this <code>Profile</code> is handled by an <code>Expression</code>. Otherwise it is intialized based on <code>profile.value</code>.</p></div></details><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">value_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).con.value_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).con.value_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/con_value_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of this <code>profile</code> to the <code>model</code>.</p><p>This heavily depends on the <code>mode</code> setting, as it does nothing if the <code>mode</code> is set to <code>fixed</code>, or the <code>value</code> is actually controlled by an <code>Expression</code>. The variable can be accessed via <code>profile.var.aux_value[t]</code>, but using the normal result extraction is recommended, since that properly handles the <code>profile.exp.value</code> instead.</p><p>Otherwise:</p><blockquote><p><code>if profile.mode === :create or profile.mode === :destroy</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{aux_value}_t \geq 0, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><blockquote><p><code>if profile.mode === :ranged</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{value}_t \geq \text{lb}_t, \qquad \forall t \in T \\
    &amp; \text{value}_t \leq \text{ub}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><p>Here, <code>lb</code> and <code>ub</code> can be left empty, which drops the respective constraint.</p></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).obj.cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).obj.cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/obj_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>Profile</code> to the global objective function.</p><p>The <code>profile.cost</code> setting specifies a potential cost for the creation (&quot;resource costs&quot;, i.e. importing gas into the model) or destruction (&quot;penalties&quot;, i.e. costs linked to the emission of CO2). It can have a unique value for every <code>Snapshot</code>, i.e. allowing to model a time-varying gas price throughout the year.</p><p>The contribution to the global objective function is as follows:</p><p class="math-container">\[\sum_{t\in T} \text{value}_t \cdot \text{profile.cost}_t \cdot \omega_t\]</p><p>math</p><p>Here <span>$\omega_t$</span> is the <code>weight</code> of <code>Snapshot</code> <code>t</code>, and <span>$\text{value}_t$</span> actually refers to the value of <code>profile.exp.value[t]</code> (and not only on the maybe non-existing variable).</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/f90d8d8a2a9ae8963808a92be6049946610c64d5/src/core/profile.jl#L1-L150">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Unit" href="#IESopt.Unit"><code>IESopt.Unit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Unit</code> allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.</p><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>conversion</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">The conversion expression describing how this <code>Unit</code> transforms energy. Specified in the form of &quot;<span>$\alpha \cdot carrier_1 + \beta \cdot carrier_2$</span> -&gt; <span>$\gamma \cdot carrier_3 + \delta \cdot carrier_4$</span>&quot;. Coefficients allow simple numerical calculations, but are not allowed to include spaces (so e.g. <code>(1.0/9.0)</code> is valid). Coefficients are allowed to be <code>NumericalInput</code>s, resulting in <code>column@data_file</code> being a valid coefficient (this can be used e.g. for time-varying COPs of heatpumps).</td></tr><tr><td style="text-align: left"><code>capacity</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">Maximum capacity of this <code>Unit</code>, to be given in the format <code>X in/out:carrier</code> where <code>X</code> is the amount, <code>in</code> or <code>out</code> (followed by <code>:</code>) specifies whether the limit is to be placed on the in- our output of this <code>Unit</code>, and <code>carrier</code> specifies the respective <code>Carrier</code>. Example: <code>100 in:electricity</code> (to limit the &quot;input rating&quot;).</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">conversion</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.conversion</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.conversion</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_conversion.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the <code>unit</code>&#39;s conversion to the <code>model</code>.</p><p>This can be accessed via <code>unit.var.conversion[t]</code>; this does not describe the full output of the <code>Unit</code> since that maybe also include fixed generation based on the <code>ison</code> variable.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This applies some heavy recalculation of efficiencies to account for minimum load and so on, that are currently not fully documented. This essentially comes down to the following: As long as minimum load is not enabled, that is rather simple (using the conversion expression to withdraw energy from the inputs and push energy into the outputs). If a separate minimum load conversion is specified it results in the following: (1) if running at minimum load the supplied minimum load conversion will be used; (2) if running at maximum capacity the &quot;normal&quot; conversion expression will be used; (3) for any point in-between a linear interpolation scales up all coefficients of the conversion expression to &quot;connect&quot; case (1) and (2).</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">conversion_connect</summary><div class="admonition-body"><p>No documentation found.</p><p><code>IESopt._unit_var_conversion_connect!</code> is a <code>Function</code>.</p><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.conversion_connect</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.conversion_connect</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_conversion_connect.jl"><code>IESopt.jl</code></a>.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">ison</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.ison</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.ison</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_ison.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the current &quot;online&quot; state of the <code>unit</code> to the <code>model</code>.</p><p>The variable can be further parameterized using the <code>unit.unit_commitment</code> setting (&quot;linear&quot;, &quot;binary&quot;, &quot;integer&quot;). It will automatically enforce the constraints <span>$0 \leq \text{ison} \leq \text{unitcount}$</span>, with <span>$\text{unitcount}$</span> describing the number of units that are aggregated in this <code>unit</code> (set by <code>unit.unit_count</code>). This can be accessed via <code>unit.var.ison[t]</code>.</p></div></details><details class="admonition is-details"><summary class="admonition-header">ramp</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.ramp</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.ramp</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_ramp.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the per-snapshot ramping to the <code>model</code>.</p><p>This adds two variables per snapshot to the model (if the respective setting <code>unit.enable_ramp_up</code> or <code>unit.enable_ramp_down</code> is activated). Both are preconstructed with a fixed lower bound of <code>0</code>. This describes the amount of change in conversion that occurs during the current snapshot. These can be accessed via <code>unit.var.ramp_up[t]</code> and <code>unit.var.ramp_down[t]</code>.</p><p>These variables are only used for ramping <strong>costs</strong>. The limits are enforced directly on the conversion, which means this variable only exists if costs are specified!</p></div></details><details class="admonition is-details"><summary class="admonition-header">startup</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.startup</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.startup</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_startup.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the per-snapshot startup to the <code>model</code>.</p><p>This adds a variable per snapshot to the model (if the respective setting <code>unit.unit_commitment</code> is activated). The variable can be further parameterized using the <code>unit.unit_commitment</code> setting (&quot;linear&quot;, &quot;binary&quot;, &quot;integer&quot;). It will automatically enforce the constraints <span>$0 \leq \text{startup} \leq \text{unitcount}$</span>, with <span>$\text{unitcount}$</span> describing the number of units that are aggregated in this <code>unit</code> (set by <code>unit.unit_count</code>). This describes the startup that happens during the current snapshot and can be accessed via <code>unit.var.startup</code>.</p></div></details><p><strong>Expressions</strong></p><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">conversion_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.conversion_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.conversion_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_conversion_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the <code>unit</code>&#39;s conversion bounds to the <code>model</code>.</p><p>This makes use of the current <code>min_capacity</code> (describing the lower limit of conversion; either 0 if no minimum load applies or the respective value of the minimum load) as well as the <code>online_capacity</code> (that can either be the full capacity if unit commitment is disabled, or the amount that is currently active).</p><p>Depending on how the &quot;availability&quot; of this <code>unit</code> is handled it constructs the following constraints:</p><blockquote><p><code>if !isnothing(unit.availability)</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{conversion}_t \geq \text{capacity}_{\text{min}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{capacity}_{\text{online}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{availability}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><p>This effectively results in <span>$\text{conversion}_t \leq \min(\text{capacity}_{\text{online}, t}, \text{availability}_t)$</span>.</p><blockquote><p><code>if !isnothing(unit.availability_factor)</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{conversion}_t \geq \text{capacity}_{\text{min}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{capacity}_{\text{online}, t} \cdot \text{availability}_{\text{factor}, t}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If one is able to choose between using <code>availability</code> or <code>availability_factor</code> (e.g. for restricting available capacity during a planned revision to half the units capacity), enabling <code>availability_factor</code> (in this example 0.5) will result in a faster model (build and probably solve) since it makes use of one less constraint.</p></div></div><p>If no kind of availability limiting takes place, the following bounds are enforced:</p><blockquote><p class="math-container">\[\begin{aligned}
    &amp; \text{conversion}_t \geq \text{capacity}_{\text{min}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{capacity}_{\text{online}, t}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote></div></details><details class="admonition is-details"><summary class="admonition-header">ison</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.ison</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.ison</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_ison.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Construct the upper bound for <code>var_ison</code>, based on <code>unit.unit_count</code>, if it is handled by an external <code>Decision</code>.</p></div></details><details class="admonition is-details"><summary class="admonition-header">min_onoff_time</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.min_onoff_time</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.min_onoff_time</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_min_onoff_time.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraints modeling min on- or off-time of a <code>Unit</code> to the <code>model</code>.</p><p>This constructs the constraints</p><p class="math-container">\[\begin{align}
    &amp; \sum_{t&#39; = t}^{t + \text{min\_on\_time}} ison_{t&#39;} &gt;= \text{min\_on\_time} \cdot (ison_t - ison_{t-1}) \qquad \forall t \in T \\
    &amp; \sum_{t&#39; = t}^{t + \text{min\_off\_time}} (1 - ison_{t&#39;}) &gt;= \text{min\_off\_time} \cdot (ison_{t-1} - ison_t) \qquad \forall t \in T
\end{align}

respecting `on_time_before` and `off_time_before`, and `is_on_before`. See the code for more details.

!!! info &quot;Aggregated units&quot;
    This is currently not fully adapted to account for `Unit`s with `unit_count &gt; 1`.\]</p><p>math</p></div></details><details class="admonition is-details"><summary class="admonition-header">ramp</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.ramp</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.ramp</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_ramp.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the auxiliary constraint that enables calculation of per snapshot ramping to the <code>model</code>.</p><p>Depending on whether ramps are enabled, none, one, or both of the following constraints are constructed:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{ramp}_{\text{up}, t} \geq \text{conversion}_{t} - \text{conversion}_{t-1}, \qquad \forall t \in T \\
    &amp; \text{ramp}_{\text{down}, t} \geq \text{conversion}_{t-1} - \text{conversion}_{t}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><p>This calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:</p><ul><li><code>out[5] = 100</code> and <code>out[4] = 50</code>, then <code>ramp_up[5] = 50</code> and <code>ramp_down[5] = 0</code></li><li><code>ramp_up[1] = ramp_down[1] = 0</code></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This currently does not support pre-setting the initial states of the unit (it can be done manually but there is no exposed parameter), which will be implemented in the future to allow for easy / correct rolling optimization runs.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">ramp_limit</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.ramp_limit</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.ramp_limit</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_ramp_limit.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint describing the ramping limits of this <code>unit</code> to the <code>model</code>.</p><p>This makes use of the maximum capacity of the <code>unit</code>, which is just the total installed capacity. Both, up- and downwards ramps can be enabled separately (via <code>unit.ramp_up_limit</code> and <code>unit.ramp_down_limit</code>), resulting in either or both of:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{ramp}_{\text{up}, t} \leq \text{ramplimit}_\text{up} \cdot \text{capacity}_\text{max} \cdot \omega_t, \qquad \forall t \in T \\
    &amp; \text{ramp}_{\text{down}, t} \leq \text{ramplimit}_\text{down} \cdot \text{capacity}_\text{max} \cdot \omega_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><p>This does <strong>not</strong> make use of the ramping variable (that is only used for costs - if there are costs).</p><p>This calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:</p><ul><li><code>out[5] = 100</code> and <code>out[4] = 50</code>, then <code>ramp_up[5] = 50</code> and <code>ramp_down[5] = 0</code></li><li><code>ramp_up[1] = ramp_down[1] = 0</code></li></ul></div></details><details class="admonition is-details"><summary class="admonition-header">startup</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.startup</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.startup</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_startup.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the auxiliary constraint that enables calculation of per snapshot startup to the <code>model</code>.</p><p>Depending on whether startup handling is enabled, the following constraint is constructed:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{startup}_{\text{up}, t} \geq \text{ison}_{t} - \text{ison}_{t-1}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><p>This calculates the startup that happens from the PREVIOUS snapshot to this one. That means that if:</p><ul><li><code>ison[5] = 1</code> and <code>ison[4] = 0</code>, then <code>startup[5] = 1</code></li></ul></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">marginal_cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).obj.marginal_cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).obj.marginal_cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/obj_marginal_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>unit</code>&#39;s conversion (<code>unit.marginal_cost</code>) to the global objective function.</p><p class="math-container">\[\sum_{t \in T} \text{conversion}_t \cdot \text{marginalcost}_t \cdot \omega_t\]</p><p>math</p></div></details><details class="admonition is-details"><summary class="admonition-header">ramp_cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).obj.ramp_cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).obj.ramp_cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/obj_ramp_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>unit</code>&#39;s ramping to the global objective function.</p><p>To allow for finer control, costs of up- and downwards ramping can be specified separately (using <code>unit.ramp_up_cost</code> and <code>unit.ramp_down_cost</code>):</p><p class="math-container">\[\sum_{t \in T} \text{ramp}_{\text{up}, t} \cdot \text{rampcost}_{\text{up}} + \text{ramp}_{\text{down}, t} \cdot \text{rampcost}_{\text{down}}\]</p><p>math</p></div></details><details class="admonition is-details"><summary class="admonition-header">startup_cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).obj.startup_cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).obj.startup_cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/obj_startup_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>unit</code>&#39;s startup behaviour (configured by <code>unit.startup_cost</code> if <code>unit.unit_commitment != :off</code>).</p><p class="math-container">\[\sum_{t \in T} \text{startup}_t \cdot \text{startupcost}\]</p><p>math</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/f90d8d8a2a9ae8963808a92be6049946610c64d5/src/core/unit.jl#L1-L423">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../yaml/">« YAML Reference</a><a class="docs-footer-nextpage" href="../templates/">Template Reference »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.4.1 on <span class="colophon-date" title="Thursday 6 June 2024 18:09">Thursday 6 June 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
