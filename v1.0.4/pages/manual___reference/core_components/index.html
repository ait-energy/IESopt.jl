<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Model formulation · -- IESopt --</title><meta name="title" content="Model formulation · -- IESopt --"/><meta property="og:title" content="Model formulation · -- IESopt --"/><meta property="twitter:title" content="Model formulation · -- IESopt --"/><meta name="description" content="Documentation for -- IESopt --."/><meta property="og:description" content="Documentation for -- IESopt --."/><meta property="twitter:description" content="Documentation for -- IESopt --."/><meta property="og:url" content="https://ait-energy.github.io/IESopt.jl/pages/manual___reference/core_components/"/><meta property="twitter:url" content="https://ait-energy.github.io/IESopt.jl/pages/manual___reference/core_components/"/><link rel="canonical" href="https://ait-energy.github.io/IESopt.jl/pages/manual___reference/core_components/"/><script data-outdated-warner src="../../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../../assets/documenter.js"></script><script src="../../../search_index.js"></script><script src="../../../siteinfo.js"></script><script src="../../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../../assets/themeswap.js"></script><link href="../../../assets/base_template.css" rel="stylesheet" type="text/css"/></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../../">-- IESopt --</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../../">Home</a></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/setup/">Installation</a></li><li><a class="tocitem" href="../../tutorials/first_model/">First steps</a></li><li><a class="tocitem" href="../../tutorials/next_steps/">Next steps</a></li><li><a class="tocitem" href="../../tutorials/results/">Result extraction</a></li><li><input class="collapse-toggle" id="menuitem-2-5" type="checkbox"/><label class="tocitem" for="menuitem-2-5"><span class="docs-label">Creating new components</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../tutorials/creating_new_components/">Custom Components</a></li><li><a class="tocitem" href="../../tutorials/creating_new_components/templates_1/">Templates: Part I</a></li><li><a class="tocitem" href="../../tutorials/creating_new_components/templates_2/">Templates: Part II</a></li></ul></li></ul></li><li><span class="tocitem">User Guide</span><ul><li><a class="tocitem" href="../../user_guide/general/">General</a></li><li><input class="collapse-toggle" id="menuitem-3-2" type="checkbox"/><label class="tocitem" for="menuitem-3-2"><span class="docs-label">Sectors</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_guide/sectors/electricity/">Electricity</a></li><li><a class="tocitem" href="../../user_guide/sectors/heat/">Heat</a></li><li><a class="tocitem" href="../../user_guide/sectors/gas/">Gas</a></li></ul></li><li><a class="tocitem" href="../../user_guide/solvers/">Solvers</a></li><li><input class="collapse-toggle" id="menuitem-3-4" type="checkbox"/><label class="tocitem" for="menuitem-3-4"><span class="docs-label">Custom functionality</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../user_guide/custom_functionality/templates/">Templates</a></li><li><a class="tocitem" href="../../user_guide/custom_functionality/addons/">Addons</a></li></ul></li><li><span class="tocitem">Examples</span></li></ul></li><li><span class="tocitem">Manual / Reference</span><ul><li><a class="tocitem" href="../yaml/">YAML</a></li><li class="is-active"><a class="tocitem" href>Model formulation</a></li><li><a class="tocitem" href="../templates/">Templates</a></li><li><a class="tocitem" href="../api/">API</a></li></ul></li><li><a class="tocitem" href="../../references/">References</a></li><li><a class="tocitem" href="../../dev_docs/">Developer Documentation</a></li><li><a class="tocitem" href="../../changelog/">Changelog</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual / Reference</a></li><li class="is-active"><a href>Model formulation</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Model formulation</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/ait-energy/IESopt.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/ait-energy/IESopt.jl/blob/dev/docs/src/pages/manual___reference/core_components.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Model-formulation"><a class="docs-heading-anchor" href="#Model-formulation">Model formulation</a><a id="Model-formulation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-formulation" title="Permalink"></a></h1><p>This page collects all information about the core components of IESopt, their properties (and default values), their internal mathematical formulations, and some examples of how to use them. See the <a href="../api/#API">API</a> for a complete list of all available functions and types.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Connection" href="#IESopt.Connection"><code>IESopt.Connection</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Connection</code> is used to model arbitrary flows of energy between <code>Node</code>s. It allows for limits, costs, delays, ...</p><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Unit</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>node_from</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">This <code>Connection</code> models a flow from <code>node_from</code> to <code>node_to</code> (both are <code>Node</code>s).</td></tr><tr><td style="text-align: left"><code>node_to</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">This <code>Connection</code> models a flow from <code>node_from</code> to <code>node_to</code> (both are <code>Node</code>s).</td></tr><tr><td style="text-align: left"><code>carrier</code></td><td style="text-align: left">no</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left"><code>Carrier</code> of this <code>Connection</code>. If not given, automatically picks the <code>carrier</code> of the <code>Node</code>s it connects. This parameter is not necessary, and only exists to allow for a more explicit definition.</td></tr><tr><td style="text-align: left"><code>capacity</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric, <code>col@file</code>, <code>decision:value</code></td><td style="text-align: left">power</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">The symmetric bound on this <code>Connection</code>&#39;s flow. Results in <code>lb = -capacity</code> and <code>ub = capacity</code>. Must not be specified if <code>lb</code>, <code>ub</code>, or both are explicitly stated.</td></tr><tr><td style="text-align: left"><code>lb</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric, <code>col@file</code>, <code>decision:value</code></td><td style="text-align: left">power</td><td style="text-align: left"><span>$-\infty$</span></td><td style="text-align: left">Lower bound of this <code>Connection</code>&#39;s flow.</td></tr><tr><td style="text-align: left"><code>ub</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric, <code>col@file</code>, <code>decision:value</code></td><td style="text-align: left">power</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">Upper bound of this <code>Connection</code>&#39;s flow.</td></tr><tr><td style="text-align: left"><code>cost</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">monetary (per energy)</td><td style="text-align: left">-</td><td style="text-align: left">Cost of every unit of energy flow over this connection that is added to the model&#39;s objective function. Keep in mind that negative flows will induce negative costs, which can be used to model revenues. Further, a bidirectional <code>Connection</code> (if <code>lb &lt; 0</code>, which is the default, or if <code>capacity</code> is used) with a positive <code>cost</code> will lead to negative costs for the reverse flow. If you do not want this, split the <code>Connection</code> into two separate ones, each being unidirectional (with <code>lb: 0</code>). Remember, that these can share the same &quot;capacity&quot; (which is then set as<code>ub</code>), even when using <code>decision:value</code> or <code>col@file</code> as value.</td></tr><tr><td style="text-align: left"><code>loss</code></td><td style="text-align: left">no</td><td style="text-align: left"><span>$\in [0, 1]$</span></td><td style="text-align: left">-</td><td style="text-align: left">0</td><td style="text-align: left">Fractional loss when transfering energy. This loss occurs &quot;at the destination&quot;, which means that for a loss of 5%, set as <code>loss: 0.05</code>, and considering a <code>Snapshot</code> where the <code>Connection</code> has a flow value of <code>100</code>, it will &quot;extract&quot; <code>100</code> from <code>node_from</code> and &quot;inject&quot; <code>95</code> into <code>node_to</code>. Since the flow variable is given as power, this would, e.g., translate to consuming 200 units of energy at <code>node_from</code> and injecting 190 units at <code>node_to</code>, if the <code>Snapshot</code> duration is 2 hours.</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">flow</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).var.flow</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).var.flow</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/var_flow.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable representing the flow of this <code>connection</code> to the <code>model</code>. This can be accessed via <code>connection.var.flow[t]</code>.</p><p>Additionally, the flow gets &quot;injected&quot; at the <code>Node</code>s that the <code>connection</code> is connecting, resulting in</p><p class="math-container">\[\begin{aligned}
   &amp; \text{connection.node}_{from}\text{.injection}_t = \text{connection.node}_{from}\text{.injection}_t - \text{flow}_t, \qquad \forall t \in T \\
   &amp; \text{connection.node}_{to}\text{.injection}_t = \text{connection.node}_{to}\text{.injection}_t + \text{flow}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><blockquote><p>For &quot;PF controlled&quot; <code>Connection</code>s (ones that define the necessary power flow parameters), the flow variable may not be constructed (depending on specific power flow being used). The automatic result extraction will detect this and return the correct values either way. Accessing it manually can be done using <code>connection.exp.pf_flow[t]</code>.</p></blockquote></div></details><p><strong>Expressions</strong></p><details class="admonition is-details"><summary class="admonition-header">pf_flow</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this expression by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).exp.pf_flow</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).exp.pf_flow</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/exp_pf_flow.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Construct the <code>JuMP.AffExpr</code> holding the PTDF based flow of this <code>Connection</code>.</p><p>This needs the global addon <code>Powerflow</code> with proper settings for <code>mode</code>, as well as properly configured power flow parameters for this <code>Connection</code> (<code>pf_V</code>, <code>pf_I</code>, <code>pf_X</code>, ...).</p></div></details><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">flow_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).con.flow_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).con.flow_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/con_flow_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of the flow (related to <code>connection</code>) to the <code>model</code>.</p><p>Specifiying <code>capacity</code> will lead to symmetric bounds (<span>$\text{lb} := -capacity$</span> and <span>$\text{ub} := capacity$</span>), while asymmetric bounds can be set by explicitly specifiying <code>lb</code> and <code>ub</code>.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Usage of <code>etdf</code> is currently not fully tested, and not documented.</p></div></div><p>Upper and lower bounds can be &quot;infinite&quot; (by not setting them) resulting in the repective constraints not being added, and the flow variable therefore being (partially) unconstrained. Depending on the configuration the <code>flow</code> is calculated differently:</p><ul><li>if <code>connection.etdf</code> is set, it is based on an ETDF sum flow,</li><li>if <code>connection.exp.pf_flow</code> is available, it equals this</li><li>else it equal <code>connection.var.flow</code></li></ul><p>This flow is then constrained:</p><blockquote><p class="math-container">\[\begin{aligned}
    &amp; \text{flow}_t \geq \text{lb}, \qquad \forall t \in T \\
    &amp; \text{flow}_t \leq \text{ub}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><div class="admonition is-info"><header class="admonition-header">Constraint safety</header><div class="admonition-body"><p>The lower and upper bound constraint are subject to penalized slacks.</p></div></div></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_connection&quot;).obj.cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_connection&quot;).obj.cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/connection/obj_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>connection</code> to the global objective function.</p><p>The <code>connection.cost</code> setting introduces a fixed cost of &quot;transportation&quot; to the flow of this <code>Connection</code>. It is based on the directed flow. This means that flows in the &quot;opposite&quot; direction will lead to negative costs:</p><p class="math-container">\[\sum_{t \in T} \text{flow}_t \cdot \text{cost}_t \cdot \omega_t\]</p><p>math</p><p>Here <span>$\omega_t$</span> is the weight of <code>Snapshot</code> <code>t</code>.</p><div class="admonition is-info"><header class="admonition-header">Costs for flows in both directions</header><div class="admonition-body"><p>If you need to apply a cost term to the absolute value of the flow, consider splitting the <code>Connection</code> into two different ones, in opposing directions, and including <code>lb = 0</code>.</p></div></div></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/331d84e62c6113dad07b997799a2260982c652dc/src/core/connection.jl#L1-L158">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Decision" href="#IESopt.Decision"><code>IESopt.Decision</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Decision</code> represents a basic decision variable in the model that can be used as input for various other core component&#39;s settings, as well as have associated costs.</p><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Unit</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>lb</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Minimum size of the decision value (considered for each &quot;unit&quot; if count allows multiple &quot;units&quot;).</td></tr><tr><td style="text-align: left"><code>ub</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">Maximum size of the decision value (considered for each &quot;unit&quot; if count allows multiple &quot;units&quot;).</td></tr><tr><td style="text-align: left"><code>cost</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">monetary (per value)</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Cost that the decision value induces, given as <span>$cost \cdot value$</span>.</td></tr><tr><td style="text-align: left"><code>fixed_value</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">If <code>mode: fixed</code>, this value is used as the fixed value of the decision. This can be useful if this <code>Decision</code> was used in a previous optimization and its value should be fixed to that value in the next optimization (applying it where ever it is used, instead of needing to find all usages). Furthermore, this allows extracting the dual value of the constraint that fixes the value, assisting in approaches like Benders decomposition. Note that this does not change the induced cost in any way.</td></tr><tr><td style="text-align: left"><code>fixed_cost</code></td><td style="text-align: left">no</td><td style="text-align: left">-</td><td style="text-align: left">monetary</td><td style="text-align: left">-</td><td style="text-align: left">This setting activates a &quot;fixed cost&quot; component for this decision variable, which requires that the model&#39;s problem type allows for binary variables (e.g., <code>MILP</code>). This can be used to model fixed costs that are only incurred if the decision variable is active (e.g., a fixed cost for an investment that is only incurred if the investment is made). If the decision is <code>0</code>, no fixed costs have to be paid; however, if the decision is greater than <code>0</code>, the fixed cost is incurred. Note that after deciding to activate the decision, the overall value is still determined in the usual (continuous) way, incuring the (variable) <code>cost</code> as well. More complex cost functions can be modelled by switching to mode <code>sos1</code> or <code>sos2</code> and using the <code>sos</code> parameter.</td></tr><tr><td style="text-align: left"><code>mode</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>linear</code>, <code>binary</code>, <code>integer</code>, <code>sos1</code>, <code>sos2</code>, <code>fixed</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>linear</code></td><td style="text-align: left">Type of the decision variable that is constructed. <code>linear</code> results in a continuous decision, <code>integer</code> results in a integer variable, <code>binary</code> constrains it to be either <code>0</code> or <code>1</code>. <code>sos1</code> and <code>sos2</code> can be used to activate SOS1 or SOS2 mode (used for piecewise linear costs). See <code>fixed_value</code> if setting this to <code>fixed</code>.</td></tr><tr><td style="text-align: left"><code>sos</code></td><td style="text-align: left">no</td><td style="text-align: left">list</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">TODO (meanwhile, refer to the SOS or PiecewiseLinearCost example).</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">fixed</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).var.fixed</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).var.fixed</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/var_fixed.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).var.sos</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).var.sos</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/var_sos.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).var.value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).var.value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/var_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the <code>value</code> of this <code>decision</code> to the <code>model</code>. If lower and upper bounds (<code>decision.lb</code> and <code>decision.ub</code>) are the same, the variable will immediately be fixed to that value. This can be accessed via <code>decision.var.value</code>.</p></div></details><p><strong>Expressions</strong></p><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">fixed</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.fixed</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.fixed</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_fixed.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos1</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.sos1</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.sos1</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_sos1.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos2</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.sos2</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.sos2</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_sos2.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><details class="admonition is-details"><summary class="admonition-header">sos_value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).con.sos_value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).con.sos_value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/con_sos_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>to be added</p></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">fixed</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).obj.fixed</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).obj.fixed</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/obj_fixed.jl"><code>IESopt.jl</code></a>.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">sos</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).obj.sos</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).obj.sos</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/obj_sos.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the cost defined by the SOS-based value of this <code>Decision</code> to the <code>model</code>.</p></div></details><details class="admonition is-details"><summary class="admonition-header">value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_decision&quot;).obj.value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_decision&quot;).obj.value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/decision/obj_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the cost defined by the value of this <code>Decision</code> to the <code>model</code>:</p><p class="math-container">\[\text{value} \cdot \text{cost}\]</p><p>math</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/331d84e62c6113dad07b997799a2260982c652dc/src/core/decision.jl#L1-L223">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Node" href="#IESopt.Node"><code>IESopt.Node</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Node</code> represents a basic intersection/hub for energy flows. This can for example be some sort of bus (for electrical systems). It enforces a nodal balance equation (= &quot;energy that flows into it must flow out&quot;) for every <a href="../api/#IESopt.Snapshot"><code>Snapshot</code></a>. Enabling the internal state of the <code>Node</code> allows it to act as energy storage, modifying the nodal balance equation. This allows using <code>Node</code>s for various storage tasks (like batteries, hydro reservoirs, heat storages, ...). </p><details class="admonition is-details"><summary class="admonition-header">Basic Examples</summary><div class="admonition-body"><p>A <code>Node</code> that represents an electrical bus:</p><pre><code class="language-yaml hljs">bus:
  type: Node
  carrier: electricity</code></pre><p>A <code>Node</code> that represents a simplified hydrogen storage:</p><pre><code class="language-yaml hljs">store:
  type: Node
  carrier: hydrogen
  has_state: true
  state_lb: 0
  state_ub: 50</code></pre></div></details><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Unit</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>carrier</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left"><code>Carrier</code> of this <code>Node</code>. All connecting components need to respect that.</td></tr><tr><td style="text-align: left"><code>has_state</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>true</code>, <code>false</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>false</code></td><td style="text-align: left">If <code>true</code>, the <code>Node</code> is considered to have an internal state (&quot;stateful <code>Node</code>&quot;). This allows it to act as energy storage. Connect <code>Connection</code>s or <code>Unit</code>s to it, acting as charger/discharger.</td></tr><tr><td style="text-align: left"><code>state_lb</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric, <code>col@file</code>, <code>decision:value</code></td><td style="text-align: left">energy</td><td style="text-align: left"><span>$-\infty$</span></td><td style="text-align: left">Lower bound of the internal state, requires <code>has_state = true</code>.</td></tr><tr><td style="text-align: left"><code>state_ub</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric, <code>col@file</code>, <code>decision:value</code></td><td style="text-align: left">energy</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">Upper bound of the internal state, requires <code>has_state = true</code>.</td></tr><tr><td style="text-align: left"><code>state_cyclic</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>eq</code>, <code>geq</code>, or <code>disabled</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>eq</code></td><td style="text-align: left">Controls how the state considers the boundary between last and first <code>Snapshot</code>. <code>disabled</code> disables cyclic behaviour of the state (see also <code>state_initial</code>), <code>eq</code> leads to the state at the end of the year being the initial state at the beginning of the year, while <code>geq</code> does the same while allowing the end-of-year state to be higher (= &quot;allowing to destroy energy at the end of the year&quot;).</td></tr><tr><td style="text-align: left"><code>state_initial</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">energy</td><td style="text-align: left">-</td><td style="text-align: left">Sets the initial state. Must be used in combination with <code>state_cyclic = disabled</code>.</td></tr><tr><td style="text-align: left"><code>state_final</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">energy</td><td style="text-align: left">-</td><td style="text-align: left">Sets the final state. Must be used in combination with <code>state_cyclic = disabled</code>.</td></tr><tr><td style="text-align: left"><code>state_percentage_loss</code></td><td style="text-align: left">no</td><td style="text-align: left"><span>$\in [0, 1]$</span></td><td style="text-align: left">-</td><td style="text-align: left">0</td><td style="text-align: left">Per <code>Snapshot</code> percentage loss of state (loosing 1% should be set as <code>0.01</code>).</td></tr><tr><td style="text-align: left"><code>nodal_balance</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>enforce</code>, <code>destroy</code>, or <code>create</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>enforce</code></td><td style="text-align: left">Can only be used for <code>has_state = false</code>. <code>enforce</code> forces total injections to always be zero (similar to Kirchhoff&#39;s current law), <code>create</code> allows &quot;supply &lt; demand&quot;, <code>destroy</code> allows &quot;supply &gt; demand&quot;, at this <code>Node</code>.</td></tr><tr><td style="text-align: left"><code>sum_window_size</code></td><td style="text-align: left">no</td><td style="text-align: left">integer</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">TODO.</td></tr><tr><td style="text-align: left"><code>sum_window_step</code></td><td style="text-align: left">no</td><td style="text-align: left">integer</td><td style="text-align: left">-</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">TODO.</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">pf_theta</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).var.pf_theta</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).var.pf_theta</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/var_pf_theta.jl"><code>IESopt.jl</code></a>.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">state</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).var.state</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).var.state</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/var_state.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable representing the state of this <code>node</code> to the <code>model</code>, if <code>node.has_state == true</code>. This can be accessed via <code>node.var.state[t]</code>.</p><p>Additionally, if the state&#39;s initial value is specified via <code>state_initial</code> the following gets added:</p><p class="math-container">\[\text{state}_1 = \text{state}_{initial}\]</p><p>math</p></div></details><p><strong>Expressions</strong></p><details class="admonition is-details"><summary class="admonition-header">injection</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this expression by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).exp.injection</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).exp.injection</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/exp_injection.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add an empty (<code>JuMP.AffExpr(0)</code>) expression to the <code>node</code> that keeps track of feed-in and withdrawal of energy.</p><p>This constructs the expression <span>$\text{injection}_t, \forall t \in T$</span> that is utilized in <code>node.con.nodalbalance</code>. Core components (<code>Connection</code>s, <code>Profile</code>s, and <code>Unit</code>s) that feed energy into this node add to it, all others subtract from it. A stateless node forces this nodal balance to always equal <code>0</code> which essentially describes &quot;generation = demand&quot;.</p></div></details><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">last_state</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).con.last_state</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).con.last_state</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/con_last_state.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of the <code>node</code>&#39;s state during the last Snapshot to the <code>model</code>, if <code>node.has_state == true</code>.</p><p>This is necessary since it could otherwise happen, that the state following the last Snapshot is actually not feasible (e.g. we could charge a storage by more than it&#39;s state allows for). The equations are based on the construction of the overall state variable.</p><p class="math-container">\[\begin{aligned}
    &amp; \text{state}_{end} \cdot \text{factor}^\omega_t + \text{injection}_{end} \cdot \omega_t \geq \text{state}_{lb} \\ 
    &amp; \text{state}_{end} \cdot \text{factor}^\omega_t + \text{injection}_{end} \cdot \omega_t \leq \text{state}_{ub} 
\end{aligned}\]</p><p>math</p><p>Here <span>$\omega_t$</span> is the <code>weight</code> of <code>Snapshot</code> <code>t</code>, and <span>$\text{factor}$</span> is either <code>1.0</code> (if there are now percentage losses configured), or <code>(1.0 - node.state_percentage_loss)</code> otherwise.</p><div class="admonition is-info"><header class="admonition-header">Constraint safety</header><div class="admonition-body"><p>The lower and upper bound constraint are subject to penalized slacks.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">nodalbalance</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).con.nodalbalance</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).con.nodalbalance</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/con_nodalbalance.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint describing the nodal balance to the <code>model</code>.</p><p>Depending on whether the <code>node</code> is stateful or not, this constructs different representations:</p><blockquote><p><code>if node.has_state == true</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{state}_t = \text{state}_{t-1} \cdot \text{factor}^\omega_{t-1} + \text{injection}_{t-1} \cdot \omega_{t-1}, \qquad \forall t \in T \setminus \{1\} \\
    \\
    &amp; \text{state}_1 = \text{state}_{end} \cdot \text{factor}^\omega_{end} + \text{injection}_{end} \cdot \omega_{end}
\end{aligned}\]</p><p>math</p></blockquote><p>Here <span>$\omega_t$</span> is the <code>weight</code> of <code>Snapshot</code> <code>t</code>, and <span>$\text{factor}$</span> is either <code>1.0</code> (if there are now percentage losses configured), or <code>(1.0 - node.state_percentage_loss)</code> otherwise. <span>$\text{injection}_{t}$</span> describes the overall injection (all feed-ins minus all withdrawals). <span>$end$</span> indicates the last snapshot in <span>$T$</span>. Depending on the setting of <code>state_cyclic</code> the second constraint is written as <span>$=$</span> (<code>&quot;eq&quot;</code>) or <span>$\leq$</span> (<code>&quot;leq&quot;</code>). The latter allows the destruction of excess energy at the end of the total time period to help with feasibility.</p><blockquote><p><code>if node.has_state == false</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{injection}_{t} = 0, \qquad \forall t \in T \\
\end{aligned}\]</p><p>math</p></blockquote><p>This equation can further be configured using the <code>nodal_balance</code> parameter, which accepts <code>enforce</code> (resulting in <span>$=$</span>), <code>create</code> (resulting in <span>$\leq$</span>; allowing the creation of energy - or &quot;negative injections&quot;), and <code>destroy</code> ( resulting in <span>$\geq$</span>; allowing the destruction of energy - or &quot;positive injections&quot;). This can be used to model some form of energy that can either be sold (using a <code>destroy</code> <code>Profile</code> connected to this <code>Node</code>), or &quot;wasted into the air&quot; using the <code>destroy</code> setting of this <code>Node</code>. </p></div></details><details class="admonition is-details"><summary class="admonition-header">state_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_node&quot;).con.state_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_node&quot;).con.state_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/node/con_state_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of the <code>node</code>&#39;s state to the <code>model</code>, if <code>node.has_state == true</code>.</p><p class="math-container">\[\begin{aligned}
    &amp; \text{state}_t \geq \text{state}_{lb}, \qquad \forall t \in T \\
    &amp; \text{state}_t \leq \text{state}_{ub}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><div class="admonition is-info"><header class="admonition-header">Constraint safety</header><div class="admonition-body"><p>The lower and upper bound constraint are subject to penalized slacks.</p></div></div></div></details><p><strong>Objectives</strong></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/331d84e62c6113dad07b997799a2260982c652dc/src/core/node.jl#L1-L228">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Profile" href="#IESopt.Profile"><code>IESopt.Profile</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Profile</code> allows representing &quot;model boundaries&quot; - parts of initial problem that are not endogenously modelled - with a support for time series data. Examples are hydro reservoir inflows, electricity demand, importing gas, and so on. Besides modelling fixed profiles, they also allow different ways to modify the value endogenously.</p><details class="admonition is-details"><summary class="admonition-header">Basic Examples</summary><div class="admonition-body"><p>A <code>Profile</code> that depicts a fixed electricity demand:</p><pre><code class="language-yaml hljs">demand_XY:
  type: Profile
  carrier: electricity
  node_from: grid
  value: demand_XY@input_file</code></pre><p>A <code>Profile</code> that handles cost of fuel:</p><pre><code class="language-yaml hljs">fuel_gas:
  type: Profile
  carrier: gas
  node_to: country_gas_grid
  mode: create
  cost: 100.0</code></pre><p>A <code>Profile</code> that handles CO2 emission costs:</p><pre><code class="language-yaml hljs">co2_cost:
  type: Profile
  carrier: co2
  node_from: total_co2
  mode: destroy
  cost: 150.0</code></pre><p>A <code>Profile</code> that handles selling electricity:</p><pre><code class="language-yaml hljs">sell_electricity:
  type: Profile
  carrier: electricity
  node_from: internal_grid_node
  mode: destroy
  cost: -30.0</code></pre></div></details><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Unit</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>carrier</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left"><code>Carrier</code> of this <code>Profile</code>. Must match the <code>Carrier</code> of the <code>Node</code> that this connects to.</td></tr><tr><td style="text-align: left"><code>value</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric, <code>col@file</code></td><td style="text-align: left">power</td><td style="text-align: left">-</td><td style="text-align: left">The concrete value of this <code>Profile</code> - either static or as time series. Only applicable if <code>mode: fixed</code>.</td></tr><tr><td style="text-align: left"><code>node_from</code></td><td style="text-align: left">no</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Name of the <code>Node</code> that this <code>Profile</code> draws energy from. Exactly one of <code>node_from</code> and <code>node_to</code> must be set.</td></tr><tr><td style="text-align: left"><code>node_to</code></td><td style="text-align: left">no</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Name of the <code>Node</code> that this <code>Profile</code> feeds energy to. Exactly one of <code>node_from</code> and <code>node_to</code> must be set.</td></tr><tr><td style="text-align: left"><code>mode</code></td><td style="text-align: left">no</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left"><code>fixed</code></td><td style="text-align: left">The mode of operation of this <code>Profile</code>. <code>fixed</code> uses the supplied <code>value</code>, <code>ranged</code> allows ranging between <code>lb</code> and <code>ub</code>, while <code>create</code> (must specify <code>node_to</code>) and <code>destroy</code> (must specify <code>node_from</code>) handle arbitrary energy flows that are bounded from below by <code>0</code>. Use <code>fixed</code> if you want to fix the value of the <code>Profile</code> to a specific value, e.g., a given energy demand. Use <code>create</code> to &quot;import&quot; energy into the model, e.g., from a not explicitly modelled gas market, indcucing a certain <code>cost</code> for buying that energy. Use <code>destroy</code> to &quot;export&quot; energy from the model, e.g., to handle CO2 going into the atmosphere (which may be taxed, etc., by the <code>cost</code> of this <code>Profile</code>). Use <code>ranged</code> if you need more fine grained control over the value of the <code>Profile</code>, than what <code>create</code> and <code>destroy</code> allow (e.g., a grid limited energy supplier).</td></tr><tr><td style="text-align: left"><code>lb</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">power</td><td style="text-align: left"><span>$-\infty$</span></td><td style="text-align: left">The lower bound of the range of this <code>Profile</code> (must be used together with <code>mode: ranged</code>).</td></tr><tr><td style="text-align: left"><code>ub</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">power</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">The upper bound of the range of this <code>Profile</code> (must be used together with <code>mode: ranged</code>).</td></tr><tr><td style="text-align: left"><code>cost</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">monetary per energy</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Cost per unit of energy that this <code>Profile</code> injects or withdraws from a <code>Node</code>. Refer to the basic examples to see how this can be combined with <code>mode</code> for different use cases.</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">aux_value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).var.aux_value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).var.aux_value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/var_aux_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable that is used in this <code>Profile</code>s value to the <code>model</code>.</p><p>The variable <code>var_value[t]</code> is constructed and is linked to the correct <code>Node</code>s. There are different ways, IESopt interprets this, based on the setting of <code>profile.mode</code>:</p><ol><li><strong>fixed</strong>: The value is already handled by the constant term of <code>profile.exp.value</code> and NO variable is constructed.</li><li><strong>create</strong>, <strong>destroy</strong>, or <strong>ranged</strong>: This models the creation or destruction of energy - used mainly to represent model boundaries, and energy that comes into the model or leaves the model&#39;s scope. It is however important that <code>create</code> should mostly be used feeding into a <code>Node</code> (<code>profile.node_from = nothing</code>) and <code>destroy</code> withdrawing from a <code>Node</code> (<code>profile.node_to = nothing</code>). If <code>lb</code> and <code>ub</code> are defined, <code>ranged</code> can be used that allows a more detailled control over the <code>Profile</code>, specifying upper and lower bounds for every <code>Snapshot</code>. See <code>_profile_con_value_bounds!(profile::Profile)</code> for details on the specific bounds for each case.</li></ol><p>This variable is added to the <code>profile.exp.value</code>. Additionally, the energy (that <code>profile.exp.value</code> represents) gets &quot;injected&quot; at the <code>Node</code>s that the <code>profile</code> is connected to, resulting in</p><p class="math-container">\[\begin{aligned}
   &amp; \text{profile.node}_{from}\text{.injection}_t = \text{profile.node}_{from}\text{.injection}_t - \text{value}_t, \qquad \forall t \in T \\
   &amp; \text{profile.node}_{to}\text{.injection}_t = \text{profile.node}_{to}\text{.injection}_t + \text{value}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></div></details><p><strong>Expressions</strong></p><details class="admonition is-details"><summary class="admonition-header">value</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this expression by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).exp.value</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).exp.value</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/exp_value.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Cosntruct the <code>JuMP.AffExpr</code> that keeps the total value of this <code>Profile</code> for each <code>Snapshot</code>.</p><p>This is skipped if the <code>value</code> of this <code>Profile</code> is handled by an <code>Expression</code>. Otherwise it is intialized based on <code>profile.value</code>.</p></div></details><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">value_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).con.value_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).con.value_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/con_value_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the bounds of this <code>profile</code> to the <code>model</code>.</p><p>This heavily depends on the <code>mode</code> setting, as it does nothing if the <code>mode</code> is set to <code>fixed</code>, or the <code>value</code> is actually controlled by an <code>Expression</code>. The variable can be accessed via <code>profile.var.aux_value[t]</code>, but using the normal result extraction is recommended, since that properly handles the <code>profile.exp.value</code> instead.</p><p>Otherwise:</p><blockquote><p><code>if profile.mode === :create or profile.mode === :destroy</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{aux_value}_t \geq 0, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><blockquote><p><code>if profile.mode === :ranged</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{value}_t \geq \text{lb}_t, \qquad \forall t \in T \\
    &amp; \text{value}_t \leq \text{ub}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><p>Here, <code>lb</code> and <code>ub</code> can be left empty, which drops the respective constraint.</p></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_profile&quot;).obj.cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_profile&quot;).obj.cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/profile/obj_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>Profile</code> to the global objective function.</p><p>The <code>profile.cost</code> setting specifies a potential cost for the creation (&quot;resource costs&quot;, i.e. importing gas into the model) or destruction (&quot;penalties&quot;, i.e. costs linked to the emission of CO2). It can have a unique value for every <code>Snapshot</code>, i.e. allowing to model a time-varying gas price throughout the year.</p><p>The contribution to the global objective function is as follows:</p><p class="math-container">\[\sum_{t\in T} \text{value}_t \cdot \text{profile.cost}_t \cdot \omega_t\]</p><p>math</p><p>Here <span>$\omega_t$</span> is the <code>weight</code> of <code>Snapshot</code> <code>t</code>, and <span>$\text{value}_t$</span> actually refers to the value of <code>profile.exp.value[t]</code> (and not only on the maybe non-existing variable).</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/331d84e62c6113dad07b997799a2260982c652dc/src/core/profile.jl#L1-L202">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="IESopt.Unit" href="#IESopt.Unit"><code>IESopt.Unit</code></a> — <span class="docstring-category">Type</span></header><section><div><p>A <code>Unit</code> allows transforming one (or many) forms of energy into another one (or many), given some constraints and costs.</p><details class="admonition is-details"><summary class="admonition-header">Basic Examples</summary><div class="admonition-body"><p>A <code>Unit</code> that represents a basic gas turbine:</p><pre><code class="language-yaml hljs">gas_turbine:
  type: Unit
  inputs: {gas: gas_grid}
  outputs: {electricity: node, co2: total_co2}
  conversion: 1 gas -&gt; 0.4 electricity + 0.2 co2
  capacity: 10 out:electricity</code></pre><p>A <code>Unit</code> that represents a basic wind turbine:</p><pre><code class="language-yaml hljs">wind_turbine:
  type: Unit
  outputs: {electricity: node}
  conversion: ~ -&gt; 1 electricity
  capacity: 10 out:electricity
  availability_factor: wind_factor@input_data
  marginal_cost: 1.7 per out:electricity</code></pre><p>A <code>Unit</code> that represents a basic heat pump, utilizing a varying COP:</p><pre><code class="language-yaml hljs">heatpump:
  type: Unit
  inputs: {electricity: grid}
  outputs: {heat: heat_system}
  conversion: 1 electricity -&gt; cop@inputfile heat
  capacity: 10 in:electricity</code></pre></div></details><p><strong>Parameters</strong></p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">Mandatory</th><th style="text-align: left">Values</th><th style="text-align: left">Unit</th><th style="text-align: left">Default</th><th style="text-align: left">Description</th></tr><tr><td style="text-align: left"><code>conversion</code></td><td style="text-align: left">yes</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">The conversion expression describing how this <code>Unit</code> transforms energy. Specified in the form of &quot;<span>$\alpha \cdot carrier_1 + \beta \cdot carrier_2$</span> -&gt; <span>$\gamma \cdot carrier_3 + \delta \cdot carrier_4$</span>&quot;. Coefficients allow simple numerical calculations, but are not allowed to include spaces (so e.g. <code>(1.0/9.0)</code> is valid). Coefficients are allowed to be <code>NumericalInput</code>s, resulting in <code>column@data_file</code> being a valid coefficient (this can be used e.g. for time-varying COPs of heatpumps).</td></tr><tr><td style="text-align: left"><code>capacity</code></td><td style="text-align: left">yes</td><td style="text-align: left">value dir:carrier</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Maximum capacity of this <code>Unit</code>, to be given in the format <code>X in/out:carrier</code> where <code>X</code> is the amount, <code>in</code> or <code>out</code> (followed by <code>:</code>) specifies whether the limit is to be placed on the in- our output of this <code>Unit</code>, and <code>carrier</code> specifies the respective <code>Carrier</code>. Example: <code>100 in:electricity</code> (to limit the &quot;input rating&quot;).</td></tr><tr><td style="text-align: left"><code>outputs</code></td><td style="text-align: left">yes</td><td style="text-align: left">dict</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Dictionary specifying the output &quot;ports&quot; of this <code>Unit</code>. Refer to the basic examples for the general syntax.</td></tr><tr><td style="text-align: left"><code>inputs</code></td><td style="text-align: left">no</td><td style="text-align: left">dict</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">Dictionary specifying the input &quot;ports&quot; of this <code>Unit</code>. If not specified (= no explicit input), the <code>conversion</code> has to follow the form of <code>conversion: ~ -&gt; ...</code>, indicating an &quot;open&quot; input. This may, e.g., be used for renewable energy sources, where the primary energy input (e.g., solar) is not explicitly modeled.</td></tr><tr><td style="text-align: left"><code>availability</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">power</td><td style="text-align: left"><span>$+\infty$</span></td><td style="text-align: left">Time series (or fixed value) that limits the available capacity. If, e.g., <code>capacity: 100 out:electricity</code> and <code>availability: 70</code>, the available capacity will only be <code>50 electricity</code>. Can be used to model non-availability of power plants, e.g., due to maintenance. For time-varying availability of intermittent generators (e.g., wind), it&#39;s recommended (most of the time) to use <code>availability_factor</code> instead.</td></tr><tr><td style="text-align: left"><code>availability_factor</code></td><td style="text-align: left">no</td><td style="text-align: left"><span>$\in [0, 1]$</span></td><td style="text-align: left">-</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Similar to <code>availability</code>, but given as factor of <code>capacity</code> instead. If, e.g., <code>capacity: 100 out:electricity</code> and <code>availability_factor: 0.7</code>, the available capacity will only be <code>70 electricity</code>. This is especially useful for intermittent generators, where the availability is not a fixed value, but depends on the weather, and can be passed, e.g., by setting <code>availability_factor: wind@input_data_file</code>.</td></tr><tr><td style="text-align: left"><code>adapt_min_to_availability</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>true</code>, <code>false</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>false</code></td><td style="text-align: left">If <code>true</code>, the minimal partial load will be influenced by the availability. Example: Consider a <code>Unit</code> with <code>capacity: 100 out:electricity</code>, a <code>min_conversion</code> of <code>0.4</code>, and an <code>availability_factor</code> of <code>0.5</code>. This entails having <code>50 electricity</code> available, while the minimal partial load is <code>40 electricity</code>. This results in the <code>Unit</code> at best operating only closely above the minimal partial load. Furthermore, an <code>availability_factor</code> below <code>0.4</code> would result in no feasible generation, besides shutting the <code>Unit</code> off. While this might be the intended mode of operation in many use cases, <code>adapt_min_to_availability</code> can change this: If set to <code>true</code>, this dynamically changes the minimal partial load. In the previous example, that means <code>(100 * 0.5) * 0.4 = 20 electricity</code> (the 50% minimum load are now based on the available 40), changing the overall behaviour (including efficiencies) as well as leading to feasible generations even when the <code>availability_factor</code> is below <code>0.4</code>.</td></tr><tr><td style="text-align: left"><code>marginal_cost</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>value per dir:carrier</code></td><td style="text-align: left">monetary per energy</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Marginal cost of the consumption/generation of one unit of energy of the specified carrier. Has to be given in the format <code>value per dir:carrier</code>, e.g. <code>3.5 per out:electricity</code> for a marginal cost of 3.5 monetary units per unit of electricity generated.</td></tr><tr><td style="text-align: left"><code>enable_ramp_up</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>true</code>, <code>false</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Enables calculation of upward ramps. Ramping is based on the carrier specified in <code>capacity</code>.</td></tr><tr><td style="text-align: left"><code>enable_ramp_down</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>true</code>, <code>false</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Enables calculation of downward ramps. Ramping is based on the carrier specified in <code>capacity</code>.</td></tr><tr><td style="text-align: left"><code>ramp_up_cost</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">monetary per power</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Sets the cost of ramping up (increasing in-/output) by 1 unit of the capacity carrier.</td></tr><tr><td style="text-align: left"><code>ramp_down_cost</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">monetary per power</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Sets the cost of ramping down (decreasing in-/output) by 1 unit of the capacity carrier.</td></tr><tr><td style="text-align: left"><code>ramp_up_limit</code></td><td style="text-align: left">no</td><td style="text-align: left"><span>$\in [0, 1]$</span></td><td style="text-align: left">-</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Limits the allowed ramping up based on this factor of the total capacity. If <code>capacity: 100 in:electricity</code> with <code>ramp_up_limit: 0.2</code>, this limits the total increase of usage of electricity (on the input) to 20 units (power) per hour. For example, starting at an input of 35, after one hour the input has to be lesser than or equal to 55. If a <code>Snapshot</code>&#39;s duration is set to, e.g., two hours, this would allow a total increase of 40 units.</td></tr><tr><td style="text-align: left"><code>ramp_down_limit</code></td><td style="text-align: left">no</td><td style="text-align: left"><span>$\in [0, 1]$</span></td><td style="text-align: left">-</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Limits the allowed ramping down based on this factor of the total capacity. See <code>ramp_up_limit</code>.</td></tr><tr><td style="text-align: left"><code>min_on_time</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">hours</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Minimum on-time of the <code>Unit</code>. If set, the <code>Unit</code> has to be on for at least this amount of time, after turning on. It is highly recommended to only use this with <code>unit_commitment: binary</code>, unless you know why it&#39;s fine to use with another mode.</td></tr><tr><td style="text-align: left"><code>min_off_time</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">hours</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Minimum off-time of the <code>Unit</code>. If set, the <code>Unit</code> has to be off for at least this amount of time, after turning off. It is highly recommended to only use this with <code>unit_commitment: binary</code>, unless you know why it&#39;s fine to use with another mode.</td></tr><tr><td style="text-align: left"><code>on_time_before</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">hours</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Time that this <code>Unit</code> has already been running before the optimization starts. Can be used in combination with <code>min_on_time</code>.</td></tr><tr><td style="text-align: left"><code>off_time_before</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">hours</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Time that this <code>Unit</code> has already been off before the optimization starts. Can be used in combination with <code>min_off_time</code>.</td></tr><tr><td style="text-align: left"><code>is_on_before</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Number of <code>Unit</code>s that should be considered to have been running before the optimization starts. Can be used in combination with <code>on_time_before</code>, especially for <code>unit_count</code> greater than 1.</td></tr><tr><td style="text-align: left"><code>unit_commitment</code></td><td style="text-align: left">no</td><td style="text-align: left"><code>off</code>, <code>linear</code>, <code>binary</code>, <code>integer</code></td><td style="text-align: left">-</td><td style="text-align: left"><code>off</code></td><td style="text-align: left">Controls how the unit commitment of this <code>Unit</code> is handled. <code>linear</code> results in the ability to startup parts of the unit (so <code>0.314159</code> is a feasible amount of &quot;turned on unit&quot;), while <code>binary</code> restricts the <code>Unit</code> to either be on (converting the <code>conversion_at_min</code> + possible additional conversion above that minimum) or off (converting nothing); <code>integer</code> is needed to consider <code>binary</code> unit commitment for <code>Unit</code>s with more than 1 &quot;grouped unit&quot; (see <code>unit_count</code>).</td></tr><tr><td style="text-align: left"><code>unit_count</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">-</td><td style="text-align: left"><code>1</code></td><td style="text-align: left">Number of units aggregated in this <code>Unit</code>. Besides interacting with the mode of <code>unit_commitment</code>, this mainly is responsible for scaling the output (e.g. grouping 47 of the same wind turbine, ...).</td></tr><tr><td style="text-align: left"><code>min_conversion</code></td><td style="text-align: left">no</td><td style="text-align: left"><span>$\in [0, 1]$</span></td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">If <code>unit_commitment</code> is not set to <code>off</code>, this specifies the percentage that is considered to be the minimal feasible partial load this <code>Unit</code> can operate at. Operating below that setpoint is not allowed, at that point the <code>conversion_at_min</code> coefficients are used, and above that they are scaled to result in <code>conversion</code> when running at full capacity.</td></tr><tr><td style="text-align: left"><code>conversion_at_min</code></td><td style="text-align: left">no</td><td style="text-align: left">string</td><td style="text-align: left">-</td><td style="text-align: left">-</td><td style="text-align: left">The conversion expression while running on the minimal partial load. Only applicable if <code>unit_commitment</code> is not <code>off</code> and <code>min_conversion</code> is explicitly set. Follows the same form as <code>conversion</code>.</td></tr><tr><td style="text-align: left"><code>startup_cost</code></td><td style="text-align: left">no</td><td style="text-align: left">numeric</td><td style="text-align: left">monetary per start</td><td style="text-align: left"><code>0</code></td><td style="text-align: left">Costs per startup (also applicable if startups are not binary or integer). This is necessary to allow <code>conversion_at_min</code> to have (at least partially) the effect that one expects, if <code>unit_commitment: linear</code>.</td></tr></table><p><strong>Detailed Model Reference</strong></p><p><strong>Variables</strong></p><details class="admonition is-details"><summary class="admonition-header">conversion</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.conversion</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.conversion</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_conversion.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the <code>unit</code>&#39;s conversion to the <code>model</code>.</p><p>This can be accessed via <code>unit.var.conversion[t]</code>; this does not describe the full output of the <code>Unit</code> since that maybe also include fixed generation based on the <code>ison</code> variable.</p><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This applies some heavy recalculation of efficiencies to account for minimum load and so on, that are currently not fully documented. This essentially comes down to the following: As long as minimum load is not enabled, that is rather simple (using the conversion expression to withdraw energy from the inputs and push energy into the outputs). If a separate minimum load conversion is specified it results in the following: (1) if running at minimum load the supplied minimum load conversion will be used; (2) if running at maximum capacity the &quot;normal&quot; conversion expression will be used; (3) for any point in-between a linear interpolation scales up all coefficients of the conversion expression to &quot;connect&quot; case (1) and (2).</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">conversion_connect</summary><div class="admonition-body"><p>No documentation found.</p><p><code>IESopt._unit_var_conversion_connect!</code> is a <code>Function</code>.</p><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.conversion_connect</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.conversion_connect</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_conversion_connect.jl"><code>IESopt.jl</code></a>.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">ison</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.ison</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.ison</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_ison.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the current &quot;online&quot; state of the <code>unit</code> to the <code>model</code>.</p><p>The variable can be further parameterized using the <code>unit.unit_commitment</code> setting (&quot;linear&quot;, &quot;binary&quot;, &quot;integer&quot;). It will automatically enforce the constraints <span>$0 \leq \text{ison} \leq \text{unitcount}$</span>, with <span>$\text{unitcount}$</span> describing the number of units that are aggregated in this <code>unit</code> (set by <code>unit.unit_count</code>). This can be accessed via <code>unit.var.ison[t]</code>.</p></div></details><details class="admonition is-details"><summary class="admonition-header">ramp</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.ramp</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.ramp</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_ramp.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the per-snapshot ramping to the <code>model</code>.</p><p>This adds two variables per snapshot to the model (if the respective setting <code>unit.enable_ramp_up</code> or <code>unit.enable_ramp_down</code> is activated). Both are preconstructed with a fixed lower bound of <code>0</code>. This describes the amount of change in conversion that occurs during the current snapshot. These can be accessed via <code>unit.var.ramp_up[t]</code> and <code>unit.var.ramp_down[t]</code>.</p><p>These variables are only used for ramping <strong>costs</strong>. The limits are enforced directly on the conversion, which means this variable only exists if costs are specified!</p></div></details><details class="admonition is-details"><summary class="admonition-header">startup</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this variable by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).var.startup</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).var.startup</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/var_startup.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the variable describing the per-snapshot startup to the <code>model</code>.</p><p>This adds a variable per snapshot to the model (if the respective setting <code>unit.unit_commitment</code> is activated). The variable can be further parameterized using the <code>unit.unit_commitment</code> setting (&quot;linear&quot;, &quot;binary&quot;, &quot;integer&quot;). It will automatically enforce the constraints <span>$0 \leq \text{startup} \leq \text{unitcount}$</span>, with <span>$\text{unitcount}$</span> describing the number of units that are aggregated in this <code>unit</code> (set by <code>unit.unit_count</code>). This describes the startup that happens during the current snapshot and can be accessed via <code>unit.var.startup</code>.</p></div></details><p><strong>Expressions</strong></p><p><strong>Constraints</strong></p><details class="admonition is-details"><summary class="admonition-header">conversion_bounds</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.conversion_bounds</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.conversion_bounds</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_conversion_bounds.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint defining the <code>unit</code>&#39;s conversion bounds to the <code>model</code>.</p><p>This makes use of the current <code>min_capacity</code> (describing the lower limit of conversion; either 0 if no minimum load applies or the respective value of the minimum load) as well as the <code>online_capacity</code> (that can either be the full capacity if unit commitment is disabled, or the amount that is currently active).</p><p>Depending on how the &quot;availability&quot; of this <code>unit</code> is handled it constructs the following constraints:</p><blockquote><p><code>if !isnothing(unit.availability)</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{conversion}_t \geq \text{capacity}_{\text{min}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{capacity}_{\text{online}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{availability}_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><p>This effectively results in <span>$\text{conversion}_t \leq \min(\text{capacity}_{\text{online}, t}, \text{availability}_t)$</span>.</p><blockquote><p><code>if !isnothing(unit.availability_factor)</code></p><p class="math-container">\[\begin{aligned}
    &amp; \text{conversion}_t \geq \text{capacity}_{\text{min}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{capacity}_{\text{online}, t} \cdot \text{availability}_{\text{factor}, t}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>If one is able to choose between using <code>availability</code> or <code>availability_factor</code> (e.g. for restricting available capacity during a planned revision to half the units capacity), enabling <code>availability_factor</code> (in this example 0.5) will result in a faster model (build and probably solve) since it makes use of one less constraint.</p></div></div><p>If no kind of availability limiting takes place, the following bounds are enforced:</p><blockquote><p class="math-container">\[\begin{aligned}
    &amp; \text{conversion}_t \geq \text{capacity}_{\text{min}, t}, \qquad \forall t \in T \\
    &amp; \text{conversion}_t \leq \text{capacity}_{\text{online}, t}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p></blockquote></div></details><details class="admonition is-details"><summary class="admonition-header">ison</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.ison</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.ison</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_ison.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Construct the upper bound for <code>var_ison</code>, based on <code>unit.unit_count</code>, if it is handled by an external <code>Decision</code>.</p></div></details><details class="admonition is-details"><summary class="admonition-header">min_onoff_time</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.min_onoff_time</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.min_onoff_time</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_min_onoff_time.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraints modeling min on- or off-time of a <code>Unit</code> to the <code>model</code>.</p><p>This constructs the constraints</p><p class="math-container">\[\begin{align}
    &amp; \sum_{t&#39; = t}^{t + \text{min\_on\_time}} ison_{t&#39;} &gt;= \text{min\_on\_time} \cdot (ison_t - ison_{t-1}) \qquad \forall t \in T \\
    &amp; \sum_{t&#39; = t}^{t + \text{min\_off\_time}} (1 - ison_{t&#39;}) &gt;= \text{min\_off\_time} \cdot (ison_{t-1} - ison_t) \qquad \forall t \in T
\end{align}

respecting `on_time_before` and `off_time_before`, and `is_on_before`. See the code for more details.

!!! info &quot;Aggregated units&quot;
    This is currently not fully adapted to account for `Unit`s with `unit_count &gt; 1`.\]</p><p>math</p></div></details><details class="admonition is-details"><summary class="admonition-header">ramp</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.ramp</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.ramp</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_ramp.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the auxiliary constraint that enables calculation of per snapshot ramping to the <code>model</code>.</p><p>Depending on whether ramps are enabled, none, one, or both of the following constraints are constructed:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{ramp}_{\text{up}, t} \geq \text{conversion}_{t} - \text{conversion}_{t-1}, \qquad \forall t \in T \\
    &amp; \text{ramp}_{\text{down}, t} \geq \text{conversion}_{t-1} - \text{conversion}_{t}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><p>This calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:</p><ul><li><code>out[5] = 100</code> and <code>out[4] = 50</code>, then <code>ramp_up[5] = 50</code> and <code>ramp_down[5] = 0</code></li><li><code>ramp_up[1] = ramp_down[1] = 0</code></li></ul><div class="admonition is-info"><header class="admonition-header">Info</header><div class="admonition-body"><p>This currently does not support pre-setting the initial states of the unit (it can be done manually but there is no exposed parameter), which will be implemented in the future to allow for easy / correct rolling optimization runs.</p></div></div></div></details><details class="admonition is-details"><summary class="admonition-header">ramp_limit</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.ramp_limit</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.ramp_limit</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_ramp_limit.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the constraint describing the ramping limits of this <code>unit</code> to the <code>model</code>.</p><p>This makes use of the maximum capacity of the <code>unit</code>, which is just the total installed capacity. Both, up- and downwards ramps can be enabled separately (via <code>unit.ramp_up_limit</code> and <code>unit.ramp_down_limit</code>), resulting in either or both of:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{ramp}_{\text{up}, t} \leq \text{ramplimit}_\text{up} \cdot \text{capacity}_\text{max} \cdot \omega_t, \qquad \forall t \in T \\
    &amp; \text{ramp}_{\text{down}, t} \leq \text{ramplimit}_\text{down} \cdot \text{capacity}_\text{max} \cdot \omega_t, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><p>This does <strong>not</strong> make use of the ramping variable (that is only used for costs - if there are costs).</p><p>This calculates the ramping that happens from the PREVIOUS snapshot to this one. That means that if:</p><ul><li><code>out[5] = 100</code> and <code>out[4] = 50</code>, then <code>ramp_up[5] = 50</code> and <code>ramp_down[5] = 0</code></li><li><code>ramp_up[1] = ramp_down[1] = 0</code></li></ul></div></details><details class="admonition is-details"><summary class="admonition-header">startup</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this constraint by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).con.startup</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).con.startup</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/con_startup.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the auxiliary constraint that enables calculation of per snapshot startup to the <code>model</code>.</p><p>Depending on whether startup handling is enabled, the following constraint is constructed:</p><p class="math-container">\[\begin{aligned}
    &amp; \text{startup}_{\text{up}, t} \geq \text{ison}_{t} - \text{ison}_{t-1}, \qquad \forall t \in T
\end{aligned}\]</p><p>math</p><p>This calculates the startup that happens from the PREVIOUS snapshot to this one. That means that if:</p><ul><li><code>ison[5] = 1</code> and <code>ison[4] = 0</code>, then <code>startup[5] = 1</code></li></ul></div></details><p><strong>Objectives</strong></p><details class="admonition is-details"><summary class="admonition-header">marginal_cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).obj.marginal_cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).obj.marginal_cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/obj_marginal_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>unit</code>&#39;s conversion (<code>unit.marginal_cost</code>) to the global objective function.</p><p class="math-container">\[\sum_{t \in T} \text{conversion}_t \cdot \text{marginalcost}_t \cdot \omega_t\]</p><p>math</p></div></details><details class="admonition is-details"><summary class="admonition-header">ramp_cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).obj.ramp_cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).obj.ramp_cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/obj_ramp_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>unit</code>&#39;s ramping to the global objective function.</p><p>To allow for finer control, costs of up- and downwards ramping can be specified separately (using <code>unit.ramp_up_cost</code> and <code>unit.ramp_down_cost</code>):</p><p class="math-container">\[\sum_{t \in T} \text{ramp}_{\text{up}, t} \cdot \text{rampcost}_{\text{up}} + \text{ramp}_{\text{down}, t} \cdot \text{rampcost}_{\text{down}}\]</p><p>math</p></div></details><details class="admonition is-details"><summary class="admonition-header">startup_cost</summary><div class="admonition-body"><div class="admonition is-success"><header class="admonition-header">How to?</header><div class="admonition-body"><p>Access this objective by using:</p><pre><code class="language-julia hljs"># Julia
component(model, &quot;your_unit&quot;).obj.startup_cost</code></pre><pre><code class="language-python hljs"># Python
model.get_component(&quot;your_unit&quot;).obj.startup_cost</code></pre><p>You can find the full implementation and all details here: <a href="https://github.com/ait-energy/IESopt.jl/tree/main/src/core/unit/obj_startup_cost.jl"><code>IESopt.jl</code></a>.</p></div></div><p>Add the (potential) cost of this <code>unit</code>&#39;s startup behaviour (configured by <code>unit.startup_cost</code> if <code>unit.unit_commitment != :off</code>).</p><p class="math-container">\[\sum_{t \in T} \text{startup}_t \cdot \text{startupcost}\]</p><p>math</p></div></details></div><a class="docs-sourcelink" target="_blank" href="https://github.com/ait-energy/IESopt.jl/blob/331d84e62c6113dad07b997799a2260982c652dc/src/core/unit.jl#L1-L481">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../yaml/">« YAML</a><a class="docs-footer-nextpage" href="../templates/">Templates »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.5.0 on <span class="colophon-date" title="Friday 26 July 2024 19:54">Friday 26 July 2024</span>. Using Julia version 1.10.4.</p></section><footer class="modal-card-foot"></footer></div></div></div></body><div data-docstringscollapsed="true"></div></html>
